<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>input_mod.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.17 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>input_mod.cpp</h1><a href="input__mod_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">  How It Works</span>
00003 <span class="comment"></span>
00004 <span class="comment">  </span>
00005 <span class="comment">  MikMod/Integration</span>
00006 <span class="comment">  --</span>
00007 <span class="comment">  We actually implement a MikMod output driver to render PCM</span>
00008 <span class="comment">  data.  When read() needs more PCM data, we ask MikMod to</span>
00009 <span class="comment">  update until we have enough data.</span>
00010 <span class="comment">*/</span>
00011 
00012 
00013 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00014 <span class="preprocessor">#include &lt;string.h&gt;</span>
00015 <span class="preprocessor">#include "<a class="code" href="input__mod_8h.html">input_mod.h</a>"</span>
00016 <span class="preprocessor">#include "<a class="code" href="debug_8h.html">debug.h</a>"</span>
00017 <span class="preprocessor">#include "<a class="code" href="utility_8h.html">utility.h</a>"</span>
00018 
00019 
00020 <span class="keyword">namespace </span>audiere {
00021 
00022   MD_DEVICE MODInputStream::drv_audiere = {
00023     <span class="stringliteral">"Audiere Output"</span>,
00024     <span class="stringliteral">"Internal Audiere Output Driver"</span>,
00025     0,
00026     VC_MAXVOICES,
00027 
00028     NULL,
00029     NULL,
00030     NULL,
00031 
00032     <span class="comment">// Sample loading</span>
00033     VC_SampleAlloc,
00034     VC_SampleGetPtr,
00035     VC_SampleLoad,
00036     VC_SampleUnload,
00037     VC_SampleSpace,
00038     VC_SampleLength,
00039 
00040     <span class="comment">// Detection and initialization</span>
00041     ADR_IsThere,
00042     ADR_Init,
00043     ADR_Exit,
00044     ADR_Update,
00045     VC_Preempt,
00046 
00047     NULL,
00048     ADR_SetSoftVoices,
00049 
00050     ADR_SetMode,
00051     ADR_GetMode,
00052 
00053     VC_SetVolume,
00054     VC_GetVolume,
00055 
00056     <span class="comment">// Voice control and voice information</span>
00057     VC_GetActiveVoices,
00058 
00059     VC_VoiceSetVolume,
00060     VC_VoiceGetVolume,
00061     VC_VoiceSetFrequency,
00062     VC_VoiceGetFrequency,
00063     VC_VoiceSetPosition,
00064     VC_VoiceGetPosition,
00065     VC_VoiceSetSurround,
00066     VC_VoiceSetResonance,
00067 
00068     VC_VoicePlay,
00069     VC_VoiceResume,
00070     VC_VoiceStop,
00071     VC_VoiceStopped,
00072     VC_VoiceReleaseSustain,
00073 
00074     VC_VoiceRealVolume
00075   };
00076 
00077 
<a name="l00078"></a><a class="code" href="classaudiere_1_1MODInputStream.html#a0">00078</a>   MODInputStream::MODInputStream() {
00079     m_file = 0;
00080 
00081     m_driver = 0;
00082     m_module = 0;
00083     m_player = 0;
00084 
00085     m_samples_left = 0;
00086     m_next_sample = m_sample_buffer;
00087 
00088     m_at_eof = <span class="keyword">false</span>;
00089   }
00090 
00091 
<a name="l00092"></a><a class="code" href="classaudiere_1_1MODInputStream.html#a1">00092</a>   MODInputStream::~MODInputStream() {
00093     <span class="keywordflow">if</span> (m_player) {
00094       Player_Free(m_player);
00095     }
00096     <span class="keywordflow">if</span> (m_module) {
00097       Unimod_Free(m_module);
00098     }
00099     <span class="keywordflow">if</span> (m_driver) {
00100       Mikmod_Exit(m_driver);
00101     }
00102   }
00103 
00104 
00105   <span class="keywordtype">bool</span>
<a name="l00106"></a><a class="code" href="classaudiere_1_1MODInputStream.html#a2">00106</a>   MODInputStream::initialize(<a class="code" href="classaudiere_1_1File.html">File</a>* file) {
00107     m_file = file;
00108 
00109     <span class="comment">// first time we run, initialize MikMod</span>
00110     <span class="keyword">static</span> <span class="keywordtype">bool</span> initialized = <span class="keyword">false</span>;
00111     <span class="keywordflow">if</span> (!initialized) {
00112       <a class="code" href="debug_8h.html#a0">ADR_GUARD</a>(<span class="stringliteral">"Initializing MikMod"</span>);
00113 
00114       Mikmod_RegisterLoader(load_it);
00115       Mikmod_RegisterLoader(load_xm);
00116       Mikmod_RegisterLoader(load_s3m);
00117       Mikmod_RegisterLoader(load_mod);
00118       Mikmod_RegisterLoader(load_stm);
00119     
00120       Mikmod_RegisterDriver(drv_audiere);
00121 
00122       initialized = <span class="keyword">true</span>;
00123     }
00124 
00125     m_stream.fp      = (FILE*)<span class="keyword">this</span>;
00126     m_stream.dp      = 0;
00127     m_stream.iobase  = 0;
00128     m_stream.seekpos = 0;
00129     m_stream.fread   = MMRead;
00130     m_stream.fwrite  = MMWrite;
00131     m_stream.fgetc   = MMGetC;
00132     m_stream.fputc   = MMPutC;
00133     m_stream.fseek   = MMSeek;
00134     m_stream.ftell   = MMTell;
00135     m_stream.feof    = MMEof;
00136 
00137     m_samples_left = 0;
00138     m_next_sample  = m_next_sample;
00139 
00140     m_at_eof = <span class="keyword">false</span>;
00141 
00142     <span class="comment">// create output device</span>
00143     m_driver = Mikmod_Init(
00144       44100, 2400, <span class="keyword">this</span>, MD_STEREO, CPU_AUTODETECT,
00145       DMODE_16BITS | DMODE_INTERP | DMODE_NOCLICK | DMODE_RESONANCE);
00146     <span class="keywordflow">if</span> (!m_driver) {
00147       m_file = 0;
00148       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00149     }
00150 
00151     <a class="code" href="debug_8h.html#a1">ADR_LOG</a>(<span class="stringliteral">"Mikmod_Init succeeded"</span>);
00152 
00153     <span class="comment">// load the song</span>
00154     m_module = Unimod_LoadFP(
00155       m_driver,
00156       &amp;m_stream,
00157       &amp;m_stream,
00158       MM_STATIC);
00159     <span class="keywordflow">if</span> (!m_module) {
00160       Mikmod_Exit(m_driver);
00161       m_driver = 0;
00162       m_file = 0;
00163       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00164     }
00165 
00166     <a class="code" href="debug_8h.html#a1">ADR_LOG</a>(<span class="stringliteral">"Unimod_LoadFP succeeded"</span>);
00167 
00168     <span class="comment">// load the samples (???)</span>
00169     <span class="keywordflow">if</span> (SL_LoadSamples(m_driver)) {
00170       Unimod_Free(m_module);
00171       m_module = 0;
00172       Mikmod_Exit(m_driver);
00173       m_driver = 0;
00174       m_file = 0;
00175       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00176     }
00177 
00178     <a class="code" href="debug_8h.html#a1">ADR_LOG</a>(<span class="stringliteral">"SL_LoadSamples succeeded"</span>);
00179 
00180     <span class="comment">// create a player</span>
00181     m_player = Player_InitSong(m_module, NULL, 0, 64);
00182     <span class="keywordflow">if</span> (!m_player) {
00183       Unimod_Free(m_module);
00184       m_module = 0;
00185       Mikmod_Exit(m_driver);
00186       m_driver = 0;
00187       m_file = 0;
00188       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00189     }
00190 
00191     <a class="code" href="debug_8h.html#a1">ADR_LOG</a>(<span class="stringliteral">"Player_InitSong succeeded"</span>);
00192 
00193     <span class="comment">// start playback of the module</span>
00194     <span class="comment">// we won't actually get samples until the read call</span>
00195     Player_Start(m_player);
00196 
00197     <a class="code" href="debug_8h.html#a1">ADR_LOG</a>(<span class="stringliteral">"Player_Start succeeded"</span>);
00198 
00199     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00200   }
00201 
00202 
00203   <span class="keywordtype">void</span>
<a name="l00204"></a><a class="code" href="classaudiere_1_1MODInputStream.html#a3">00204</a>   MODInputStream::getFormat(
00205     <span class="keywordtype">int</span>&amp; channel_count,
00206     <span class="keywordtype">int</span>&amp; sample_rate,
00207     <a class="code" href="namespaceaudiere.html#a59">SampleFormat</a>&amp; <a class="code" href="namespaceaudiere_1_1hidden.html#a6">sample_format</a>)
00208   {
00209     channel_count = 2;
00210     sample_rate   = 44100;
00211     <a class="code" href="namespaceaudiere_1_1hidden.html#a6">sample_format</a> = <a class="code" href="namespaceaudiere.html#a59a1">SF_S16</a>;
00212   }
00213 
00214 
00215   <span class="keywordtype">int</span>
<a name="l00216"></a><a class="code" href="classaudiere_1_1MODInputStream.html#a4">00216</a>   MODInputStream::read(<span class="keywordtype">int</span> frame_count, <span class="keywordtype">void</span>* buffer) {
00217     <a class="code" href="debug_8h.html#a0">ADR_GUARD</a>(<span class="stringliteral">"MODInputStream::read"</span>);
00218 
00219     <a class="code" href="namespaceaudiere.html#a17">u32</a>* out = static_cast&lt;u32*&gt;(buffer);
00220 
00221     <span class="keywordtype">int</span> total_written = 0;
00222     <span class="keywordflow">while</span> (frame_count &gt; 0) {
00223 
00224       <span class="comment">// if there are no frames in the buffer, tell mikmod to give us a few</span>
00225       <span class="keywordflow">if</span> (m_samples_left == 0) {
00226 
00227         <span class="comment">// if the song isn't playing any more, just stop</span>
00228         <span class="keywordflow">if</span> (!Player_Active(m_player)) {
00229           <span class="keywordflow">break</span>;
00230         }
00231 
00232         Mikmod_Update(m_driver);
00233       }
00234 
00235       <span class="comment">// read data out of the buffer</span>
00236       <a class="code" href="namespaceaudiere.html#a17">u32</a> samples_to_read = std::min&lt;u32&gt;(
00237         frame_count,
00238         m_samples_left);
00239       memcpy(out, m_next_sample, samples_to_read * 4);
00240 
00241       <span class="comment">// update pointers and indices and counts, oh my</span>
00242       out            += samples_to_read;    
00243       m_next_sample  += samples_to_read;
00244       m_samples_left -= samples_to_read;
00245       frame_count    -= samples_to_read;
00246       total_written  += samples_to_read;
00247     }
00248 
00249     <span class="keywordflow">return</span> total_written;
00250   }
00251 
00252 
00253   <span class="keywordtype">void</span>
<a name="l00254"></a><a class="code" href="classaudiere_1_1MODInputStream.html#a5">00254</a>   MODInputStream::reset() {
00255     <a class="code" href="debug_8h.html#a0">ADR_GUARD</a>(<span class="stringliteral">"MOD_Reset"</span>);
00256 
00257     m_samples_left = 0;
00258     m_next_sample  = m_sample_buffer;
00259 
00260     Player_Stop(m_player);
00261     Player_Start(m_player);
00262   }
00263 
00264 
00265   BOOL
00266   MODInputStream::ADR_IsThere() {
00267     <span class="keywordflow">return</span> 1;
00268   }
00269 
00270 
00271   BOOL
00272   MODInputStream::ADR_Init(MDRIVER* md, uint latency, <span class="keywordtype">void</span>* optstr) {
00273     <a class="code" href="debug_8h.html#a0">ADR_GUARD</a>(<span class="stringliteral">"ADR_Init"</span>);
00274 
00275     md-&gt;device.vc = VC_Init();
00276     <span class="keywordflow">if</span> (!md-&gt;device.vc) {
00277       <span class="keywordflow">return</span> 1;
00278     }
00279 
00280     md-&gt;device.local = optstr;
00281     <span class="keywordflow">return</span> 0;
00282   }
00283 
00284 
00285   <span class="keywordtype">void</span>
00286   MODInputStream::ADR_Exit(MDRIVER* md) {
00287     <a class="code" href="debug_8h.html#a0">ADR_GUARD</a>(<span class="stringliteral">"ADR_Exit"</span>);
00288 
00289     VC_Exit(md-&gt;device.vc);
00290   }
00291 
00292 
00293   <span class="keywordtype">void</span>
00294   MODInputStream::ADR_Update(MDRIVER* md) {
00295     <a class="code" href="debug_8h.html#a0">ADR_GUARD</a>(<span class="stringliteral">"ADR_Update"</span>);
00296 
00297     <a class="code" href="classaudiere_1_1MODInputStream.html#a0">MODInputStream</a>* stream = reinterpret_cast&lt;MODInputStream*&gt;(md-&gt;device.local);
00298 
00299     <span class="comment">// we should only write into the buffer if it's empty</span>
00300     <span class="keywordflow">if</span> (stream-&gt;m_samples_left != 0) {
00301       <span class="keywordflow">return</span>;
00302     }
00303 
00304     VC_WriteBytes(
00305       md,
00306       (<span class="keywordtype">signed</span> <span class="keywordtype">char</span>*)stream-&gt;m_sample_buffer,
00307       SAMPLE_BUFFER_SIZE * <span class="keyword">sizeof</span>(<a class="code" href="namespaceaudiere.html#a17">u32</a>));
00308     stream-&gt;m_samples_left = SAMPLE_BUFFER_SIZE;
00309     stream-&gt;m_next_sample = stream-&gt;m_sample_buffer;
00310   }
00311 
00312 
00313   BOOL
00314   MODInputStream::ADR_SetSoftVoices(MDRIVER* md, uint voices) {
00315     <span class="keywordflow">return</span> VC_SetSoftVoices(md-&gt;device.vc, voices);
00316   }
00317 
00318 
00319   BOOL
00320   MODInputStream::ADR_SetMode(
00321     MDRIVER* md, uint mixspeed, uint mode,
00322     uint channels, uint cpumode)
00323   {
00324     <span class="keywordflow">return</span> VC_SetMode(md-&gt;device.vc, mixspeed, mode, channels, cpumode);
00325   }
00326 
00327 
00328   <span class="keywordtype">void</span>
00329   MODInputStream::ADR_GetMode(
00330     MDRIVER* md, uint* mixspeed, uint* mode,
00331     uint* channels, uint* cpumode)
00332   {
00333     VC_GetMode(md-&gt;device.vc, mixspeed, mode, channels, cpumode);
00334   }
00335 
00336 
00337   <span class="keywordtype">int</span> <a class="code" href="input__mod_8h.html#a0">CRT_CALL</a>
00338   MODInputStream::MMRead(
00339     <span class="keywordtype">void</span>* buffer, size_t size, size_t count, FILE* stream)
00340   {
00341     <a class="code" href="classaudiere_1_1MODInputStream.html#a0">MODInputStream</a>* istream = reinterpret_cast&lt;MODInputStream*&gt;(stream);
00342     <span class="keywordtype">int</span> result = istream-&gt;m_file-&gt;read(buffer, size * count) / size;
00343     <span class="keywordflow">if</span> (result == 0) {
00344       istream-&gt;m_at_eof = <span class="keyword">true</span>;
00345     }
00346     <span class="keywordflow">return</span> result;
00347   }
00348 
00349 
00350   <span class="keywordtype">int</span> <a class="code" href="input__mod_8h.html#a0">CRT_CALL</a>
00351   MODInputStream::MMWrite(
00352     <span class="keyword">const</span> <span class="keywordtype">void</span>* buffer, size_t size, size_t count, FILE* stream)
00353   {
00354     <span class="comment">// we can't write</span>
00355     <span class="keywordflow">return</span> -1;
00356   }
00357 
00358 
00359   <span class="keywordtype">int</span> <a class="code" href="input__mod_8h.html#a0">CRT_CALL</a>
00360   MODInputStream::MMGetC(FILE* stream) {
00361     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c;
00362     <span class="keywordflow">if</span> (MMRead(&amp;c, 1, 1, stream) == 1) {
00363       <span class="keywordflow">return</span> c;
00364     } <span class="keywordflow">else</span> {
00365      <span class="keywordflow">return</span> EOF;
00366     }
00367   }
00368 
00369 
00370   <span class="keywordtype">int</span> <a class="code" href="input__mod_8h.html#a0">CRT_CALL</a>
00371   MODInputStream::MMPutC(<span class="keywordtype">int</span> c, FILE* stream) {
00372     <span class="keywordtype">char</span> ch = (char)c;
00373     <span class="keywordflow">return</span> MMWrite(&amp;ch, 1, 1, stream);
00374   }
00375 
00376 
00377   <span class="keywordtype">int</span> <a class="code" href="input__mod_8h.html#a0">CRT_CALL</a>
00378   MODInputStream::MMSeek(FILE* stream, <span class="keywordtype">long</span> offset, <span class="keywordtype">int</span> origin) {
00379     <a class="code" href="classaudiere_1_1MODInputStream.html#a0">MODInputStream</a>* istream = reinterpret_cast&lt;MODInputStream*&gt;(stream);
00380     File* file = istream-&gt;m_file.get();
00381 
00382     File::SeekMode seek_mode;
00383     <span class="keywordflow">switch</span> (origin) {
00384       <span class="keywordflow">case</span> SEEK_SET: seek_mode = File::BEGIN;   <span class="keywordflow">break</span>;
00385       <span class="keywordflow">case</span> SEEK_CUR: seek_mode = File::CURRENT; <span class="keywordflow">break</span>;
00386       <span class="keywordflow">case</span> SEEK_END: seek_mode = File::END;     <span class="keywordflow">break</span>;
00387       <span class="keywordflow">default</span>: <span class="keywordflow">return</span> -1;
00388     }
00389 
00390     <span class="keywordflow">return</span> file-&gt;seek(offset, seek_mode) ? 0 : -1;
00391   }
00392 
00393 
00394   <span class="keywordtype">int</span> <a class="code" href="input__mod_8h.html#a0">CRT_CALL</a>
00395   MODInputStream::MMTell(FILE* stream) {
00396     <a class="code" href="classaudiere_1_1MODInputStream.html#a0">MODInputStream</a>* istream = reinterpret_cast&lt;MODInputStream*&gt;(stream);
00397     File* file = istream-&gt;m_file.get();
00398     <span class="keywordflow">return</span> file-&gt;tell();
00399   }
00400 
00401 
00402   <span class="keywordtype">int</span> <a class="code" href="input__mod_8h.html#a0">CRT_CALL</a>
00403   MODInputStream::MMEof(FILE* stream) {
00404     <a class="code" href="classaudiere_1_1MODInputStream.html#a0">MODInputStream</a>* istream = reinterpret_cast&lt;MODInputStream*&gt;(stream);
00405     <span class="keywordflow">return</span> istream-&gt;m_at_eof ? 1 : 0;
00406   }
00407 
00408 }
</pre></div><hr><address style="align: right;"><small>Generated on Sat Sep 7 15:33:40 2002 for audiere by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.17 </small></address>
</body>
</html>
