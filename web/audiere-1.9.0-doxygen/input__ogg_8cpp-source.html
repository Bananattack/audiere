<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>input_ogg.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.17 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>input_ogg.cpp</h1><a href="input__ogg_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="preprocessor">#include &lt;string.h&gt;</span>
00002 <span class="preprocessor">#include "<a class="code" href="input__ogg_8h.html">input_ogg.h</a>"</span>
00003 <span class="preprocessor">#include "<a class="code" href="types_8h.html">types.h</a>"</span>
00004 <span class="preprocessor">#include "<a class="code" href="utility_8h.html">utility.h</a>"</span>
00005 
00006 
00007 <span class="keyword">namespace </span>audiere {
00008 
<a name="l00009"></a><a class="code" href="namespaceaudiere.html#a4">00009</a>   <span class="keyword">typedef</span> ogg_int64_t <a class="code" href="namespaceaudiere.html#a4">int64_t</a>;
00010 
00011 
<a name="l00012"></a><a class="code" href="classaudiere_1_1OGGInputStream.html#a0">00012</a>   OGGInputStream::OGGInputStream() {
00013     m_file = 0;
00014 
00015     m_channel_count = 0;
00016     m_sample_rate   = 0;
00017     m_sample_format = <a class="code" href="namespaceaudiere.html#a59a1">SF_S16</a>;
00018   }
00019 
00020 
<a name="l00021"></a><a class="code" href="classaudiere_1_1OGGInputStream.html#a1">00021</a>   OGGInputStream::~OGGInputStream() {
00022     <span class="comment">// were we initialized successfully?</span>
00023     <span class="keywordflow">if</span> (m_file) {
00024       ov_clear(&amp;m_vorbis_file);
00025     }
00026   }
00027 
00028 
00029   <span class="keywordtype">bool</span>
<a name="l00030"></a><a class="code" href="classaudiere_1_1OGGInputStream.html#a2">00030</a>   OGGInputStream::initialize(<a class="code" href="classaudiere_1_1File.html">File</a>* file) {
00031     m_file = file;
00032 
00033     <span class="comment">// custom ogg vorbis callbacks</span>
00034     ov_callbacks callbacks;
00035     callbacks.read_func  = FileRead;
00036     callbacks.seek_func  = FileSeek;
00037     callbacks.close_func = FileClose;
00038     callbacks.tell_func  = FileTell;
00039 
00040     <span class="comment">// open ogg vorbis stream</span>
00041     <span class="keywordtype">int</span> result = ov_open_callbacks(file, &amp;m_vorbis_file, 0, 0, callbacks);
00042     <span class="keywordflow">if</span> (result) {
00043       m_file = 0;
00044       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00045     }
00046 
00047     <span class="comment">// calculate stream type</span>
00048     vorbis_info* vi = ov_info(&amp;m_vorbis_file, -1);
00049     <span class="keywordflow">if</span> (!vi) {
00050       ov_clear(&amp;m_vorbis_file);
00051       m_file = 0;
00052       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00053     }
00054 
00055     m_channel_count = vi-&gt;channels;
00056     m_sample_rate   = vi-&gt;rate;
00057     m_sample_format = <a class="code" href="namespaceaudiere.html#a59a1">SF_S16</a>; <span class="comment">// see constructor</span>
00058 
00059     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00060   }
00061 
00062 
00063   <span class="keywordtype">void</span>
<a name="l00064"></a><a class="code" href="classaudiere_1_1OGGInputStream.html#a3">00064</a>   OGGInputStream::getFormat(
00065     <span class="keywordtype">int</span>&amp; channel_count,
00066     <span class="keywordtype">int</span>&amp; sample_rate,
00067     <a class="code" href="namespaceaudiere.html#a59">SampleFormat</a>&amp; <a class="code" href="namespaceaudiere_1_1hidden.html#a6">sample_format</a>)
00068   {
00069     channel_count = m_channel_count;
00070     sample_rate   = m_sample_rate;
00071     <a class="code" href="namespaceaudiere_1_1hidden.html#a6">sample_format</a> = m_sample_format;
00072   }
00073 
00074 
00075   <span class="keywordtype">int</span>
<a name="l00076"></a><a class="code" href="classaudiere_1_1OGGInputStream.html#a4">00076</a>   OGGInputStream::read(<span class="keywordtype">int</span> frame_count, <span class="keywordtype">void</span>* buffer) {
00077     <span class="keywordtype">int</span> sample_size = m_channel_count * <a class="code" href="namespaceaudiere.html#a22">GetSampleSize</a>(m_sample_format);
00078 
00079     <a class="code" href="namespaceaudiere.html#a13">u8</a>* out = (<a class="code" href="namespaceaudiere.html#a13">u8</a>*)buffer;
00080 
00081     <span class="keywordtype">int</span> samples_left = frame_count;
00082     <span class="keywordtype">int</span> total_read = 0;
00083     <span class="keywordflow">while</span> (samples_left &gt; 0) {
00084 
00085       <span class="comment">// check to see if the stream format has changed</span>
00086       <span class="comment">// if so, treat it as an EndOfStream</span>
00087       vorbis_info* vi = ov_info(&amp;m_vorbis_file, -1);
00088       <span class="keywordflow">if</span> (vi &amp;&amp; (m_sample_rate != vi-&gt;rate || m_channel_count != vi-&gt;channels)) {
00089         <span class="keywordflow">break</span>;
00090       }
00091 
00092 <span class="preprocessor">#ifdef WORDS_BIGENDIAN</span>
00093 <span class="preprocessor"></span><span class="preprocessor">#define ENDIANNESS 1</span>
00094 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00095 <span class="preprocessor"></span><span class="preprocessor">#define ENDIANNESS 0</span>
00096 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00097 <span class="preprocessor"></span>
00098       <span class="keywordtype">int</span> bitstream;
00099       <span class="keywordtype">long</span> result = ov_read(
00100         &amp;m_vorbis_file,
00101         (<span class="keywordtype">char</span>*)out,
00102         samples_left * sample_size,
00103         ENDIANNESS,
00104         2,  <span class="comment">// 16-bit</span>
00105         1,  <span class="comment">// signed</span>
00106         &amp;bitstream);
00107 
00108       <span class="keywordflow">if</span> (result &lt; 0) {
00109         <span class="comment">// if error, ignore it</span>
00110         <span class="keywordflow">continue</span>;
00111       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (result == 0) {
00112         <span class="keywordflow">break</span>;
00113       }
00114 
00115       <a class="code" href="namespaceaudiere.html#a17">u32</a> samples_read = (u32)(result / sample_size);
00116 
00117       out += samples_read * sample_size;
00118       samples_left -= samples_read;
00119       total_read   += samples_read;
00120     }
00121 
00122     <span class="keywordflow">return</span> total_read;
00123   }
00124 
00125 
00126   <span class="keywordtype">void</span>
<a name="l00127"></a><a class="code" href="classaudiere_1_1OGGInputStream.html#a5">00127</a>   OGGInputStream::reset() {
00128     ov_pcm_seek(&amp;m_vorbis_file, 0);
00129   }
00130 
00131 
00132   <span class="keywordtype">bool</span>
<a name="l00133"></a><a class="code" href="classaudiere_1_1OGGInputStream.html#a6">00133</a>   OGGInputStream::isSeekable() {
00134     <span class="keywordflow">return</span> (ov_seekable(&amp;m_vorbis_file) != 0);
00135   }
00136 
00137 
00138   <span class="keywordtype">int</span>
<a name="l00139"></a><a class="code" href="classaudiere_1_1OGGInputStream.html#a7">00139</a>   OGGInputStream::getLength() {
00140     <span class="keywordflow">if</span> (<a class="code" href="classaudiere_1_1OGGInputStream.html#a6">isSeekable</a>()) {
00141       <span class="keywordflow">return</span> ov_pcm_total(&amp;m_vorbis_file, -1);
00142     } <span class="keywordflow">else</span> {
00143       <span class="keywordflow">return</span> 0;
00144     }
00145   }
00146 
00147 
00148   <span class="keywordtype">void</span>
<a name="l00149"></a><a class="code" href="classaudiere_1_1OGGInputStream.html#a8">00149</a>   OGGInputStream::setPosition(<span class="keywordtype">int</span> position) {
00150     <span class="keywordflow">if</span> (<a class="code" href="classaudiere_1_1OGGInputStream.html#a6">isSeekable</a>()) {
00151       ov_pcm_seek(&amp;m_vorbis_file, position);
00152     }
00153   }
00154 
00155 
00156   <span class="keywordtype">int</span>
<a name="l00157"></a><a class="code" href="classaudiere_1_1OGGInputStream.html#a9">00157</a>   OGGInputStream::getPosition() {
00158     <span class="keywordflow">if</span> (<a class="code" href="classaudiere_1_1OGGInputStream.html#a6">isSeekable</a>()) {
00159       <span class="keywordflow">return</span> ov_pcm_tell(&amp;m_vorbis_file);
00160     } <span class="keywordflow">else</span> {
00161       <span class="keywordflow">return</span> 0;
00162     }
00163   }
00164 
00165 
00166   size_t
00167   OGGInputStream::FileRead(<span class="keywordtype">void</span>* buffer, size_t size, size_t n, <span class="keywordtype">void</span>* opaque) {
00168     File* file = reinterpret_cast&lt;File*&gt;(opaque);
00169     <span class="keywordflow">return</span> file-&gt;read(buffer, size * n) / size;
00170   }
00171 
00172 
00173   <span class="keywordtype">int</span>
00174   OGGInputStream::FileSeek(<span class="keywordtype">void</span>* opaque, ogg_int64_t offset, <span class="keywordtype">int</span> whence) {
00175     File* file = reinterpret_cast&lt;File*&gt;(opaque);
00176     File::SeekMode type;
00177     <span class="keywordflow">switch</span> (whence) {
00178       <span class="keywordflow">case</span> SEEK_SET: type = File::BEGIN;   <span class="keywordflow">break</span>;
00179       <span class="keywordflow">case</span> SEEK_CUR: type = File::CURRENT; <span class="keywordflow">break</span>;
00180       <span class="keywordflow">case</span> SEEK_END: type = File::END;     <span class="keywordflow">break</span>;
00181       <span class="keywordflow">default</span>: <span class="keywordflow">return</span> -1;
00182     }
00183     <span class="keywordflow">return</span> (file-&gt;seek((<span class="keywordtype">int</span>)offset, type) ? 0 : -1);
00184   }
00185 
00186 
00187   <span class="keywordtype">int</span>
00188   OGGInputStream::FileClose(<span class="keywordtype">void</span>* <span class="comment">/*opaque*/</span>) {
00189     <span class="comment">// we don't have to do anything</span>
00190     <span class="comment">// (read: don't trust ogg vorbis with handling file closes)</span>
00191     <span class="keywordflow">return</span> 0;
00192   }
00193 
00194 
00195   <span class="keywordtype">long</span>
00196   OGGInputStream::FileTell(<span class="keywordtype">void</span>* opaque) {
00197     File* file = reinterpret_cast&lt;File*&gt;(opaque);
00198     <span class="keywordflow">return</span> file-&gt;tell();
00199   }
00200 
00201 }
</pre></div><hr><address style="align: right;"><small>Generated on Sat Sep 7 15:33:40 2002 for audiere by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.17 </small></address>
</body>
</html>
