<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>input_wav.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.17 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>input_wav.cpp</h1><a href="input__wav_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="preprocessor">#include &lt;string.h&gt;</span>
00002 <span class="preprocessor">#include "<a class="code" href="input__wav_8h.html">input_wav.h</a>"</span>
00003 <span class="preprocessor">#include "<a class="code" href="utility_8h.html">utility.h</a>"</span>
00004 
00005 
00006 <span class="keyword">namespace </span>audiere {
00007 
00008   <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> IsValidSampleSize(<a class="code" href="namespaceaudiere.html#a28">u32</a> size) {
00009     <span class="keywordflow">return</span> (size == 8 || size == 16);
00010   }
00011 
00012 
<a name="l00013"></a><a class="code" href="classaudiere_1_1WAVInputStream.html#a0">00013</a>   WAVInputStream::WAVInputStream() {
00014     m_file = 0;
00015 
00016     m_channel_count = 0;
00017     m_sample_rate   = 0;
00018     m_sample_format = <a class="code" href="namespaceaudiere.html#a83a6">SF_U8</a>;  <span class="comment">// reasonable default?</span>
00019 
00020     m_data_chunk_location = 0;
00021     m_data_chunk_length   = 0;
00022 
00023     m_frames_left_in_chunk = 0;
00024   }
00025 
00026 
00027   <span class="keywordtype">bool</span>
<a name="l00028"></a><a class="code" href="classaudiere_1_1WAVInputStream.html#a1">00028</a>   WAVInputStream::initialize(<a class="code" href="classaudiere_1_1File.html">File</a>* file) {
00029     m_file = file;
00030 
00031     <span class="comment">// read the RIFF header</span>
00032     <span class="keywordtype">char</span> riff_id[4];
00033     <a class="code" href="namespaceaudiere.html#a24">u8</a>   riff_length_buffer[4];
00034     <span class="keywordtype">char</span> riff_datatype[4];
00035 
00036     <a class="code" href="namespaceaudiere.html#a28">u32</a> size = 0;
00037     size += file-&gt;<a class="code" href="classaudiere_1_1File.html#a0">read</a>(riff_id, 4);
00038     size += file-&gt;<a class="code" href="classaudiere_1_1File.html#a0">read</a>(riff_length_buffer, 4);
00039     size += file-&gt;<a class="code" href="classaudiere_1_1File.html#a0">read</a>(riff_datatype, 4);
00040 
00041     <span class="keywordtype">int</span> riff_length = <a class="code" href="namespaceaudiere.html#a79">read32_le</a>(riff_length_buffer);
00042 
00043     <span class="keywordflow">if</span> (size != 12 ||
00044         memcmp(riff_id, <span class="stringliteral">"RIFF"</span>, 4) != 0 ||
00045         riff_length == 0 ||
00046         memcmp(riff_datatype, <span class="stringliteral">"WAVE"</span>, 4) != 0) {
00047 
00048       <span class="comment">// so we don't destroy the file</span>
00049       m_file = 0;
00050       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00051     }
00052 
00053     <span class="keywordflow">if</span> (FindFormatChunk() &amp;&amp; FindDataChunk()) {
00054       <span class="keywordflow">return</span> <span class="keyword">true</span>;
00055     } <span class="keywordflow">else</span> {
00056       m_file = 0;
00057       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00058     }
00059   }
00060 
00061 
00062   <span class="keywordtype">void</span>
<a name="l00063"></a><a class="code" href="classaudiere_1_1WAVInputStream.html#a2">00063</a>   WAVInputStream::getFormat(
00064     <span class="keywordtype">int</span>&amp; channel_count,
00065     <span class="keywordtype">int</span>&amp; sample_rate,
00066     <a class="code" href="namespaceaudiere.html#a83">SampleFormat</a>&amp; <a class="code" href="namespaceaudiere_1_1hidden.html#a6">sample_format</a>)
00067   {
00068     channel_count = m_channel_count;
00069     sample_rate   = m_sample_rate;
00070     <a class="code" href="namespaceaudiere_1_1hidden.html#a6">sample_format</a> = m_sample_format;
00071   }
00072 
00073 
00074   <span class="keywordtype">int</span>
<a name="l00075"></a><a class="code" href="classaudiere_1_1WAVInputStream.html#a3">00075</a>   WAVInputStream::read(<span class="keywordtype">int</span> frame_count, <span class="keywordtype">void</span>* buffer) {
00076     <span class="keywordflow">if</span> (m_frames_left_in_chunk == 0) {
00077       <span class="keywordflow">return</span> 0;
00078     }
00079 
00080     <span class="keyword">const</span> <span class="keywordtype">int</span> frames_to_read = std::min(frame_count, m_frames_left_in_chunk);
00081     <span class="keyword">const</span> <span class="keywordtype">int</span> frame_size = m_channel_count * <a class="code" href="namespaceaudiere.html#a35">GetSampleSize</a>(m_sample_format);
00082     <span class="keyword">const</span> <span class="keywordtype">int</span> bytes_to_read = frames_to_read * frame_size;
00083   
00084     <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="classaudiere_1_1WAVInputStream.html#a3">read</a> = m_file-&gt;read(buffer, bytes_to_read);
00085     <span class="keyword">const</span> <span class="keywordtype">int</span> frames_read = <a class="code" href="classaudiere_1_1WAVInputStream.html#a3">read</a> / frame_size;
00086 
00087 <span class="preprocessor">#if WORDS_BIGENDIAN</span>
00088 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (m_sample_format == <a class="code" href="namespaceaudiere.html#a83a7">SF_S16</a>) {
00089       <span class="comment">// make little endian into host endian</span>
00090       <a class="code" href="namespaceaudiere.html#a24">u8</a>* out = (<a class="code" href="namespaceaudiere.html#a24">u8</a>*)buffer;
00091       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; frames_read * m_channel_count; ++i) {
00092         std::swap(out[0], out[1]);
00093         out += 2;
00094       }
00095     }
00096 <span class="preprocessor">#endif</span>
00097 <span class="preprocessor"></span>
00098     <span class="comment">// assume that if we didn't get a full read, we're done</span>
00099     <span class="keywordflow">if</span> (<a class="code" href="classaudiere_1_1WAVInputStream.html#a3">read</a> != bytes_to_read) {
00100       m_frames_left_in_chunk = 0;
00101       <span class="keywordflow">return</span> frames_read;
00102     }
00103 
00104     m_frames_left_in_chunk -= frames_read;
00105     <span class="keywordflow">return</span> frames_read;
00106   }
00107 
00108 
00109   <span class="keywordtype">void</span>
<a name="l00110"></a><a class="code" href="classaudiere_1_1WAVInputStream.html#a4">00110</a>   WAVInputStream::reset() {
00111     <span class="comment">// seek to the beginning of the data chunk</span>
00112     m_frames_left_in_chunk = m_data_chunk_length;
00113     m_file-&gt;seek(m_data_chunk_location, File::BEGIN);
00114   }
00115 
00116 
00117   <span class="keywordtype">bool</span>
<a name="l00118"></a><a class="code" href="classaudiere_1_1WAVInputStream.html#a5">00118</a>   WAVInputStream::isSeekable() {
00119     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00120   }
00121 
00122 
00123   <span class="keywordtype">int</span>
<a name="l00124"></a><a class="code" href="classaudiere_1_1WAVInputStream.html#a6">00124</a>   WAVInputStream::getLength() {
00125     <span class="keywordflow">return</span> m_data_chunk_length;
00126   }
00127 
00128 
00129   <span class="keywordtype">void</span>
<a name="l00130"></a><a class="code" href="classaudiere_1_1WAVInputStream.html#a7">00130</a>   WAVInputStream::setPosition(<span class="keywordtype">int</span> position) {
00131     <span class="keywordtype">int</span> frame_size = m_channel_count * <a class="code" href="namespaceaudiere.html#a35">GetSampleSize</a>(m_sample_format);
00132     m_frames_left_in_chunk = m_data_chunk_length - position;
00133     m_file-&gt;seek(m_data_chunk_location + position * frame_size, File::BEGIN);
00134   }
00135 
00136 
00137   <span class="keywordtype">int</span>
<a name="l00138"></a><a class="code" href="classaudiere_1_1WAVInputStream.html#a8">00138</a>   WAVInputStream::getPosition() {
00139     <span class="keywordflow">return</span> m_data_chunk_length - m_frames_left_in_chunk;
00140   }
00141 
00142 
00143   <span class="keywordtype">bool</span>
00144   WAVInputStream::FindFormatChunk() {
00145     <span class="comment">// seek to just after the RIFF header</span>
00146     m_file-&gt;seek(12, File::BEGIN);
00147 
00148     <span class="comment">// search for a format chunk</span>
00149     <span class="keywordflow">for</span> (;;) {
00150       <span class="keywordtype">char</span> chunk_id[4];
00151       <a class="code" href="namespaceaudiere.html#a24">u8</a>   chunk_length_buffer[4];
00152 
00153       <span class="keywordtype">int</span> size = m_file-&gt;read(chunk_id, 4);
00154       size    += m_file-&gt;read(chunk_length_buffer, 4);
00155       <a class="code" href="namespaceaudiere.html#a28">u32</a> chunk_length = <a class="code" href="namespaceaudiere.html#a79">read32_le</a>(chunk_length_buffer);
00156 
00157       <span class="comment">// if we couldn't read enough, we're done</span>
00158       <span class="keywordflow">if</span> (size != 8) {
00159         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00160       }
00161 
00162       <span class="comment">// if we found a format chunk, excellent!</span>
00163       <span class="keywordflow">if</span> (memcmp(chunk_id, <span class="stringliteral">"fmt "</span>, 4) == 0 &amp;&amp; chunk_length &gt;= 16) {
00164 
00165         <span class="comment">// read format chunk</span>
00166         <a class="code" href="namespaceaudiere.html#a24">u8</a> chunk[16];
00167         size = m_file-&gt;read(chunk, 16);
00168 
00169         <span class="comment">// could we read the entire format chunk?</span>
00170         <span class="keywordflow">if</span> (size &lt; 16) {
00171           <span class="keywordflow">return</span> <span class="keyword">false</span>;
00172         }
00173 
00174         chunk_length -= size;
00175 
00176         <span class="comment">// parse the memory into useful information</span>
00177         <a class="code" href="namespaceaudiere.html#a26">u16</a> format_tag         = <a class="code" href="namespaceaudiere.html#a77">read16_le</a>(chunk + 0);
00178         <a class="code" href="namespaceaudiere.html#a26">u16</a> channel_count      = <a class="code" href="namespaceaudiere.html#a77">read16_le</a>(chunk + 2);
00179         <a class="code" href="namespaceaudiere.html#a28">u32</a> samples_per_second = <a class="code" href="namespaceaudiere.html#a79">read32_le</a>(chunk + 4);
00180         <a class="code" href="namespaceaudiere.html#a28">u32</a> bytes_per_second   = <a class="code" href="namespaceaudiere.html#a79">read32_le</a>(chunk + 8);
00181         <a class="code" href="namespaceaudiere.html#a26">u16</a> block_align        = <a class="code" href="namespaceaudiere.html#a77">read16_le</a>(chunk + 12);
00182         <a class="code" href="namespaceaudiere.html#a26">u16</a> bits_per_sample    = <a class="code" href="namespaceaudiere.html#a77">read16_le</a>(chunk + 14);
00183 
00184         <span class="comment">// format_tag must be 1 (WAVE_FORMAT_PCM)</span>
00185         <span class="comment">// we only support mono and stereo</span>
00186         <span class="keywordflow">if</span> (format_tag != 1 ||
00187             channel_count &gt; 2 ||
00188             !IsValidSampleSize(bits_per_sample)) {
00189           <span class="keywordflow">return</span> <span class="keyword">false</span>;
00190         }
00191 
00192         <span class="comment">// skip the rest of the chunk</span>
00193         <span class="keywordflow">if</span> (!SkipBytes(chunk_length)) {
00194           <span class="comment">// oops, end of stream</span>
00195           <span class="keywordflow">return</span> <span class="keyword">false</span>;
00196         }
00197 
00198         <span class="comment">// figure out the sample format</span>
00199         <span class="keywordflow">if</span> (bits_per_sample == 8) {
00200           m_sample_format = <a class="code" href="namespaceaudiere.html#a83a6">SF_U8</a>;
00201         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bits_per_sample == 16) {
00202           m_sample_format = <a class="code" href="namespaceaudiere.html#a83a7">SF_S16</a>;
00203         } <span class="keywordflow">else</span> {
00204           <span class="keywordflow">return</span> <span class="keyword">false</span>;
00205         }
00206 
00207         <span class="comment">// store the other important .wav attributes</span>
00208         m_channel_count = channel_count;
00209         m_sample_rate   = samples_per_second;
00210         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00211 
00212       } <span class="keywordflow">else</span> {
00213 
00214         <span class="comment">// skip the rest of the chunk</span>
00215         <span class="keywordflow">if</span> (!SkipBytes(chunk_length)) {
00216           <span class="comment">// oops, end of stream</span>
00217           <span class="keywordflow">return</span> <span class="keyword">false</span>;
00218         }
00219 
00220       }
00221     }
00222   }
00223 
00224 
00225   <span class="keywordtype">bool</span>
00226   WAVInputStream::FindDataChunk() {
00227     <span class="comment">// seek to just after the RIFF header</span>
00228     m_file-&gt;seek(12, File::BEGIN);
00229 
00230     <span class="comment">// search for a format chunk</span>
00231     <span class="keywordflow">while</span> (true) {
00232       <span class="keywordtype">char</span> chunk_id[4];
00233       <a class="code" href="namespaceaudiere.html#a24">u8</a>   chunk_length_buffer[4];
00234 
00235       <span class="keywordtype">int</span> size = m_file-&gt;read(chunk_id, 4);
00236       size    += m_file-&gt;read(chunk_length_buffer, 4);
00237       <a class="code" href="namespaceaudiere.html#a28">u32</a> chunk_length = <a class="code" href="namespaceaudiere.html#a79">read32_le</a>(chunk_length_buffer);
00238 
00239       <span class="comment">// if we couldn't read enough, we're done</span>
00240       <span class="keywordflow">if</span> (size != 8) {
00241         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00242       }
00243 
00244       <span class="comment">// if we found a data chunk, excellent!</span>
00245       <span class="keywordflow">if</span> (memcmp(chunk_id, <span class="stringliteral">"data"</span>, 4) == 0) {
00246 
00247         <span class="comment">// calculate the frame size so we can truncate the data chunk</span>
00248         <span class="keywordtype">int</span> frame_size = m_channel_count * <a class="code" href="namespaceaudiere.html#a35">GetSampleSize</a>(m_sample_format);
00249 
00250         m_data_chunk_location  = m_file-&gt;tell();
00251         m_data_chunk_length    = chunk_length / frame_size;
00252         m_frames_left_in_chunk = m_data_chunk_length;
00253         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00254 
00255       } <span class="keywordflow">else</span> {
00256 
00257         <span class="comment">// skip the rest of the chunk</span>
00258         <span class="keywordflow">if</span> (!SkipBytes(chunk_length)) {
00259           <span class="comment">// oops, end of stream</span>
00260           <span class="keywordflow">return</span> <span class="keyword">false</span>;
00261         }
00262 
00263       }
00264     }
00265   }
00266 
00267 
00268   <span class="keywordtype">bool</span>
00269   WAVInputStream::SkipBytes(<span class="keywordtype">int</span> size) {
00270     <span class="keywordflow">return</span> m_file-&gt;seek(size, File::CURRENT);
00271   }
00272 
00273 
00274 }
</pre></div><hr><address style="align: right;"><small>Generated on Sat Oct 12 01:43:03 2002 for audiere by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.17 </small></address>
</body>
</html>
