<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>input_flac.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc1 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>input_flac.cpp</h1><a href="input__flac_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="preprocessor">#include "<a class="code" href="input__flac_8h.html">input_flac.h</a>"</span>
00002 <span class="preprocessor">#include "<a class="code" href="types_8h.html">types.h</a>"</span>
00003 <span class="preprocessor">#include "<a class="code" href="utility_8h.html">utility.h</a>"</span>
00004 
00005 
00006 <span class="keyword">namespace </span>audiere {
<a name="l00007"></a><a class="code" href="classaudiere_1_1FLACInputStream.html#a0">00007</a> 
00008   FLACInputStream::FLACInputStream() {
00009     m_decoder = 0;
00010 
00011     m_channel_count = 0;
00012     m_sample_rate   = 0;
00013     m_sample_format = <a class="code" href="namespaceaudiere.html#a105a8">SF_S16</a>;
00014 
00015     m_length = 0;
00016     m_position = 0;
00017   }
00018 
<a name="l00019"></a><a class="code" href="classaudiere_1_1FLACInputStream.html#a1">00019</a> 
00020   FLACInputStream::~FLACInputStream() {
00021     <span class="keywordflow">if</span> (m_decoder) {
00022       FLAC__seekable_stream_decoder_finish(m_decoder);
00023       FLAC__seekable_stream_decoder_delete(m_decoder);
00024       m_decoder = 0;
00025     }
00026   }
00027 
00028 
<a name="l00029"></a><a class="code" href="classaudiere_1_1FLACInputStream.html#a2">00029</a>   <span class="keywordtype">bool</span>
00030   FLACInputStream::initialize(<a class="code" href="namespaceaudiere.html#a0">FilePtr</a> file) {
00031     m_file = file;
00032 
00033     <span class="comment">// initialize the decoder</span>
00034     m_decoder = FLAC__seekable_stream_decoder_new();
00035     <span class="keywordflow">if</span> (!m_decoder) {
00036       m_file = 0;
00037       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00038     }
00039 
00040 <span class="preprocessor">#define SET_CALLBACK(name)                                   \</span>
00041 <span class="preprocessor">  FLAC__seekable_stream_decoder_set_##name##_callback(       \</span>
00042 <span class="preprocessor">    m_decoder,                                               \</span>
00043 <span class="preprocessor">    name##_callback)</span>
00044 <span class="preprocessor"></span>
00045     <span class="comment">// set callbacks</span>
00046     FLAC__seekable_stream_decoder_set_client_data      (m_decoder, <span class="keyword">this</span>);
00047     SET_CALLBACK(<a class="code" href="classaudiere_1_1BasicSource.html#a1">read</a>);
00048     SET_CALLBACK(seek);
00049     SET_CALLBACK(tell);
00050     SET_CALLBACK(length);
00051     SET_CALLBACK(eof);
00052     SET_CALLBACK(write);
00053     SET_CALLBACK(metadata);
00054     SET_CALLBACK(error);
00055 
00056     FLAC__SeekableStreamDecoderState state =
00057       FLAC__seekable_stream_decoder_init(m_decoder);
00058     <span class="keywordflow">if</span> (state != FLAC__SEEKABLE_STREAM_DECODER_OK) {
00059       FLAC__seekable_stream_decoder_finish(m_decoder);
00060       FLAC__seekable_stream_decoder_delete(m_decoder);
00061       m_decoder = 0;
00062       m_file = 0;
00063       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00064     }
00065 
00066     <span class="comment">// make sure we have metadata before we return!</span>
00067     <span class="keywordflow">if</span> (!FLAC__seekable_stream_decoder_process_until_end_of_metadata(m_decoder)) {
00068       FLAC__seekable_stream_decoder_finish(m_decoder);
00069       FLAC__seekable_stream_decoder_delete(m_decoder);
00070       m_decoder = 0;
00071       m_file = 0;
00072       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00073     }
00074 
00075     <span class="comment">// process one frame so we can do something!</span>
00076     <span class="keywordflow">if</span> (!FLAC__seekable_stream_decoder_process_single(m_decoder)) {
00077       FLAC__seekable_stream_decoder_finish(m_decoder);
00078       FLAC__seekable_stream_decoder_delete(m_decoder);
00079       m_decoder = 0;
00080       m_file = 0;
00081       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00082     }
00083 
00084     <span class="comment">// get info about the flac file</span>
00085     m_channel_count = FLAC__seekable_stream_decoder_get_channels(m_decoder);
00086     m_sample_rate   = FLAC__seekable_stream_decoder_get_sample_rate(m_decoder);
00087     <span class="keywordtype">int</span> bps         = FLAC__seekable_stream_decoder_get_bits_per_sample(m_decoder);
00088     <span class="keywordflow">if</span> (bps == 16) {
00089       m_sample_format = <a class="code" href="namespaceaudiere.html#a105a8">SF_S16</a>;
00090     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bps == 8) {
00091       m_sample_format = <a class="code" href="namespaceaudiere.html#a105a7">SF_U8</a>;
00092     } <span class="keywordflow">else</span> {
00093       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00094     }
00095 
00096     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00097   }
00098 
00099 
<a name="l00100"></a><a class="code" href="classaudiere_1_1FLACInputStream.html#a3">00100</a>   <span class="keywordtype">void</span>
00101   FLACInputStream::getFormat(
00102     <span class="keywordtype">int</span>&amp; channel_count,
00103     <span class="keywordtype">int</span>&amp; sample_rate,
00104     <a class="code" href="namespaceaudiere.html#a105">SampleFormat</a>&amp; <a class="code" href="namespaceaudiere_1_1hidden.html#a7">sample_format</a>)
00105   {
00106     channel_count = m_channel_count;
00107     sample_rate   = m_sample_rate;
00108     <a class="code" href="namespaceaudiere_1_1hidden.html#a7">sample_format</a> = m_sample_format;
00109   }
00110 
00111 
<a name="l00112"></a><a class="code" href="classaudiere_1_1FLACInputStream.html#a4">00112</a>   <span class="keywordtype">int</span>
00113   FLACInputStream::doRead(<span class="keywordtype">int</span> frame_count, <span class="keywordtype">void</span>* samples) {
00114     <span class="keyword">const</span> <span class="keywordtype">int</span> frame_size = m_channel_count * <a class="code" href="namespaceaudiere.html#a45">GetSampleSize</a>(m_sample_format);
00115     <a class="code" href="namespaceaudiere.html#a33">u8</a>* out = (<a class="code" href="namespaceaudiere.html#a33">u8</a>*)samples;
00116     
00117     <span class="comment">// we keep reading till we finish topping up!</span>
00118     <span class="keywordtype">int</span> frames_read = 0;
00119     <span class="keywordflow">while</span> (frames_read &lt; frame_count) {
00120       
00121       <span class="comment">// if the buffer is empty, ask FLAC to fill it p</span>
00122       <span class="keywordflow">if</span> (m_buffer.<a class="code" href="classaudiere_1_1QueueBuffer.html#a2">getSize</a>() &lt; frame_size) {
00123         <span class="keywordflow">if</span> (!FLAC__seekable_stream_decoder_process_single(m_decoder)) {
00124           <span class="keywordflow">return</span> frames_read;
00125         }
00126 
00127         <span class="comment">// if the buffer still has a size of 0, we are probably at the</span>
00128         <span class="comment">// end of the stream</span>
00129         <span class="keywordflow">if</span> (m_buffer.<a class="code" href="classaudiere_1_1QueueBuffer.html#a2">getSize</a>() &lt; frame_size) {
00130           <span class="keywordflow">return</span> frames_read;
00131         }
00132       }
00133 
00134       <span class="comment">// read what we've got!</span>
00135       <span class="keyword">const</span> <span class="keywordtype">int</span> to_read = std::min(
00136         frame_count - frames_read,
00137         m_buffer.<a class="code" href="classaudiere_1_1QueueBuffer.html#a2">getSize</a>() / frame_size);
00138       m_buffer.<a class="code" href="classaudiere_1_1QueueBuffer.html#a4">read</a>(out, to_read * frame_size);
00139       out += to_read * frame_size;
00140       frames_read += to_read;
00141     }
00142 
00143     <span class="keywordflow">return</span> frames_read;
00144   }
00145 
00146 
<a name="l00147"></a><a class="code" href="classaudiere_1_1FLACInputStream.html#a5">00147</a>   <span class="keywordtype">void</span>
00148   FLACInputStream::reset() {
00149     m_file-&gt;seek(0, File::BEGIN);
00150     FLAC__seekable_stream_decoder_seek_absolute(m_decoder, 0);
00151     m_position = 0;
00152     m_buffer.<a class="code" href="classaudiere_1_1QueueBuffer.html#a5">clear</a>();
00153   }
00154 
00155 
<a name="l00156"></a><a class="code" href="classaudiere_1_1FLACInputStream.html#a6">00156</a>   <span class="keywordtype">bool</span>
00157   FLACInputStream::isSeekable() {
00158     <span class="keywordflow">return</span> (m_length != 0);
00159   }
00160 
00161 
<a name="l00162"></a><a class="code" href="classaudiere_1_1FLACInputStream.html#a7">00162</a>   <span class="keywordtype">int</span>
00163   FLACInputStream::getLength() {
00164     <span class="keywordflow">return</span> m_length;
00165   }
00166 
00167 
<a name="l00168"></a><a class="code" href="classaudiere_1_1FLACInputStream.html#a8">00168</a>   <span class="keywordtype">void</span>
00169   FLACInputStream::setPosition(<span class="keywordtype">int</span> position) {
00170     <span class="keywordflow">if</span> (FLAC__seekable_stream_decoder_seek_absolute(m_decoder, position)) {
00171       m_position = position;
00172     }
00173   }
00174 
00175 
<a name="l00176"></a><a class="code" href="classaudiere_1_1FLACInputStream.html#a9">00176</a>   <span class="keywordtype">int</span>
00177   FLACInputStream::getPosition() {
00178     <span class="keywordtype">int</span> bytes_per_frame = m_channel_count * <a class="code" href="namespaceaudiere.html#a45">GetSampleSize</a>(m_sample_format);
00179     <span class="keywordflow">return</span> m_position - (m_buffer.<a class="code" href="classaudiere_1_1QueueBuffer.html#a2">getSize</a>() / bytes_per_frame);
00180   }
00181 
00182 
00183   FLAC__StreamDecoderWriteStatus
00184   FLACInputStream::write(
00185     <span class="keyword">const</span> FLAC__Frame* frame,
00186     <span class="keyword">const</span> FLAC__int32* <span class="keyword">const</span> buffer[])
00187   {
00188     <span class="keywordtype">int</span> channel_count = frame-&gt;header.channels;
00189     <span class="keywordtype">int</span> samples_per_channel = frame-&gt;header.blocksize;
00190     <span class="keywordtype">int</span> bytes_per_sample = frame-&gt;header.bits_per_sample / 8;
00191     <span class="keywordtype">int</span> total_size = channel_count * samples_per_channel * bytes_per_sample;
00192 
00193     m_multiplexer.ensureSize(total_size);
00194 
00195     <span class="comment">// do the multiplexing/interleaving</span>
00196     <span class="keywordflow">if</span> (bytes_per_sample == 1) {
00197       <a class="code" href="namespaceaudiere.html#a33">u8</a>* out = (<a class="code" href="namespaceaudiere.html#a33">u8</a>*)m_multiplexer.get();
00198       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> s = 0; s &lt; samples_per_channel; ++s) {
00199         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = 0; c &lt; channel_count; ++c) {
00200           <span class="comment">// is this right?</span>
00201           *out++ = (u8)buffer[c][s];
00202         }
00203       }
00204     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bytes_per_sample == 2) {
00205       <a class="code" href="namespaceaudiere.html#a36">s16</a>* out = (<a class="code" href="namespaceaudiere.html#a36">s16</a>*)m_multiplexer.get();
00206       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> s = 0; s &lt; samples_per_channel; ++s) {
00207         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = 0; c &lt; channel_count; ++c) {
00208           *out++ = (s16)buffer[c][s];
00209         }
00210       }
00211     } <span class="keywordflow">else</span> {
00212       <span class="keywordflow">return</span> FLAC__STREAM_DECODER_WRITE_STATUS_ABORT;
00213     }
00214 
00215     m_buffer.write(m_multiplexer.get(), total_size);
00216     m_position += samples_per_channel;
00217     <span class="keywordflow">return</span> FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
00218   }
00219 
00220 
00221   FLAC__SeekableStreamDecoderReadStatus FLACInputStream::read_callback(
00222     <span class="keyword">const</span> FLAC__SeekableStreamDecoder* decoder,
00223     FLAC__byte buffer[],
00224     <span class="keywordtype">unsigned</span> *bytes,
00225     <span class="keywordtype">void</span>* client_data)
00226   {
00227     *bytes = getFile(client_data)-&gt;read(buffer, *bytes);
00228     <span class="keywordflow">if</span> (*bytes == 0) {
00229       <span class="keywordflow">return</span> FLAC__SEEKABLE_STREAM_DECODER_READ_STATUS_ERROR;
00230     } <span class="keywordflow">else</span> {
00231       <span class="keywordflow">return</span> FLAC__SEEKABLE_STREAM_DECODER_READ_STATUS_OK;
00232     }
00233   }
00234 
00235 
00236   FLAC__SeekableStreamDecoderSeekStatus FLACInputStream::seek_callback(
00237     <span class="keyword">const</span> FLAC__SeekableStreamDecoder* decoder,
00238     FLAC__uint64 absolute_byte_offset,
00239     <span class="keywordtype">void</span>* client_data)
00240   {
00241     <span class="keywordflow">if</span> (getFile(client_data)-&gt;seek(absolute_byte_offset, File::BEGIN)) {
00242       <span class="keywordflow">return</span> FLAC__SEEKABLE_STREAM_DECODER_SEEK_STATUS_OK;
00243     } <span class="keywordflow">else</span> {
00244       <span class="keywordflow">return</span> FLAC__SEEKABLE_STREAM_DECODER_SEEK_STATUS_ERROR;
00245     }
00246   }
00247 
00248 
00249   FLAC__SeekableStreamDecoderTellStatus FLACInputStream::tell_callback(
00250     <span class="keyword">const</span> FLAC__SeekableStreamDecoder* decoder,
00251     FLAC__uint64* absolute_byte_offset,
00252     <span class="keywordtype">void</span>* client_data)
00253   {
00254     *absolute_byte_offset = getFile(client_data)-&gt;tell();
00255     <span class="keywordflow">return</span> FLAC__SEEKABLE_STREAM_DECODER_TELL_STATUS_OK;
00256   }
00257 
00258 
00259   FLAC__SeekableStreamDecoderLengthStatus FLACInputStream::length_callback(
00260     <span class="keyword">const</span> FLAC__SeekableStreamDecoder* decoder,
00261     FLAC__uint64* stream_length,
00262     <span class="keywordtype">void</span>* client_data)
00263   {
00264     *stream_length = <a class="code" href="namespaceaudiere.html#a103">GetFileLength</a>(getFile(client_data));
00265     <span class="keywordflow">return</span> FLAC__SEEKABLE_STREAM_DECODER_LENGTH_STATUS_OK;
00266   }
00267 
00268 
00269   FLAC__bool FLACInputStream::eof_callback(
00270     <span class="keyword">const</span> FLAC__SeekableStreamDecoder* decoder,
00271     <span class="keywordtype">void</span>* client_data)
00272   {
00273     File* file = getFile(client_data);
00274     <span class="keywordflow">return</span> (file-&gt;tell() == <a class="code" href="namespaceaudiere.html#a103">GetFileLength</a>(file));
00275   }
00276 
00277 
00278   FLAC__StreamDecoderWriteStatus FLACInputStream::write_callback(
00279     <span class="keyword">const</span> FLAC__SeekableStreamDecoder* decoder,
00280     <span class="keyword">const</span> FLAC__Frame* frame,
00281     <span class="keyword">const</span> FLAC__int32* <span class="keyword">const</span> buffer[],
00282     <span class="keywordtype">void</span>* client_data)
00283   {
00284     <span class="keywordflow">return</span> getStream(client_data)-&gt;write(frame, buffer);
00285   }
00286 
00287 
00288   <span class="keywordtype">void</span> FLACInputStream::metadata_callback(
00289     <span class="keyword">const</span> FLAC__SeekableStreamDecoder* decoder,
00290     <span class="keyword">const</span> FLAC__StreamMetadata *metadata,
00291     <span class="keywordtype">void</span>* client_data)
00292   {
00293     <span class="keywordflow">if</span> (metadata-&gt;type == FLAC__METADATA_TYPE_STREAMINFO) {
00294       FLAC__uint64 length = metadata-&gt;data.stream_info.total_samples;
00295       getStream(client_data)-&gt;m_length = length;
00296     }
00297   }
00298 
00299 
00300   <span class="keywordtype">void</span> FLACInputStream::error_callback(
00301     <span class="keyword">const</span> FLAC__SeekableStreamDecoder* decoder,
00302     FLAC__StreamDecoderErrorStatus status,
00303     <span class="keywordtype">void</span>* client_data)
00304   {
00305     <span class="comment">// don't handle any errors</span>
00306   }
00307 
00308 
00309   FLACInputStream* FLACInputStream::getStream(<span class="keywordtype">void</span>* client_data) {
00310     <span class="keywordflow">return</span> static_cast&lt;FLACInputStream*&gt;(client_data);
00311   }
00312 
00313   File* FLACInputStream::getFile(<span class="keywordtype">void</span>* client_data) {
00314     <span class="keywordflow">return</span> getStream(client_data)-&gt;m_file.get();
00315   }
00316 }
</pre></div><hr><address style="align: right;"><small>Generated on Tue Jul 15 12:36:49 2003 for audiere by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc1 </small></address>
</body>
</html>
