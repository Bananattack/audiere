<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>input_mod.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.8.1 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>input_mod.cpp</h1><a href="input__mod_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/*</font>
00002 <font class="comment"></font>
00003 <font class="comment">  How It Works</font>
00004 <font class="comment"></font>
00005 <font class="comment">  </font>
00006 <font class="comment">  MikMod/Integration</font>
00007 <font class="comment">  --</font>
00008 <font class="comment">  We actually implement a MikMod output driver to render PCM</font>
00009 <font class="comment">  data.  When AcqRead needs more PCM data, we ask MikMod to</font>
00010 <font class="comment">  update until we have enough data.</font>
00011 <font class="comment"></font>
00012 <font class="comment">*/</font>
00013 
00014 
00015 <font class="preprocessor">#include &lt;stdio.h&gt;</font>
00016 <font class="preprocessor">#include &lt;string.h&gt;</font>
00017 <font class="preprocessor">#include "<a class="code" href="input__mod_8hpp.html">input_mod.hpp</a>"</font>
00018 <font class="preprocessor">#include "<a class="code" href="debug_8hpp.html">debug.hpp</a>"</font>
00019 <font class="preprocessor">#include "<a class="code" href="utility_8hpp.html">utility.hpp</a>"</font>
00020 
00021 
00022 MD_DEVICE MODInputStream::drv_acq =
00023 {
00024   <font class="stringliteral">"Audiere Output"</font>,
00025   <font class="stringliteral">"Internal Audiere Output Driver"</font>,
00026   0,
00027   VC_MAXVOICES,
00028 
00029   NULL,
00030   NULL,
00031   NULL,
00032 
00033   <font class="comment">// Sample loading</font>
00034   VC_SampleAlloc,
00035   VC_SampleGetPtr,
00036   VC_SampleLoad,
00037   VC_SampleUnload,
00038   VC_SampleSpace,
00039   VC_SampleLength,
00040 
00041   <font class="comment">// Detection and initialization</font>
00042   ACQ_IsThere,
00043   ACQ_Init,
00044   ACQ_Exit,
00045   ACQ_Update,
00046   VC_Preempt,
00047 
00048   NULL,
00049   ACQ_SetSoftVoices,
00050 
00051   ACQ_SetMode,
00052   ACQ_GetMode,
00053 
00054   VC_SetVolume,
00055   VC_GetVolume,
00056 
00057   <font class="comment">// Voice control and voice information</font>
00058   VC_GetActiveVoices,
00059 
00060   VC_VoiceSetVolume,
00061   VC_VoiceGetVolume,
00062   VC_VoiceSetFrequency,
00063   VC_VoiceGetFrequency,
00064   VC_VoiceSetPosition,
00065   VC_VoiceGetPosition,
00066   VC_VoiceSetSurround,
00067   VC_VoiceSetResonance,
00068 
00069   VC_VoicePlay,
00070   VC_VoiceResume,
00071   VC_VoiceStop,
00072   VC_VoiceStopped,
00073   VC_VoiceReleaseSustain,
00074 
00075   VC_VoiceRealVolume
00076 };
00077 
00078 
00080 
<a name="l00081"></a><a class="code" href="classMODInputStream.html#a0">00081</a> <a class="code" href="classMODInputStream.html#a0">MODInputStream::MODInputStream</a>()<font class="keyword"></font>
00082 <font class="keyword"></font>{
00083   m_file = 0;
00084 
00085   m_driver = 0;
00086   m_module = 0;
00087   m_player = 0;
00088 
00089   m_samples_left = 0;
00090   m_next_sample = m_sample_buffer;
00091 
00092   m_at_eof = <font class="keyword">false</font>;
00093 }
00094 
00096 
<a name="l00097"></a><a class="code" href="classMODInputStream.html#a1">00097</a> <a class="code" href="classMODInputStream.html#a1">MODInputStream::~MODInputStream</a>()<font class="keyword"></font>
00098 <font class="keyword"></font>{
00099   <font class="comment">// were we initialized successfully?</font>
00100   <font class="keywordflow">if</font> (m_file) {
00101     
00102     Player_Free(m_player);
00103     Unimod_Free(m_module);
00104     Mikmod_Exit(m_driver);
00105 
00106     <font class="keyword">delete</font> m_file;
00107     m_file = 0;
00108   }
00109 }
00110 
00112 
00113 <font class="keywordtype">bool</font>
<a name="l00114"></a><a class="code" href="classMODInputStream.html#a2">00114</a> <a class="code" href="classMODInputStream.html#a2">MODInputStream::Initialize</a>(<a class="code" href="classIFile.html">IFile</a>* file)<font class="keyword"></font>
00115 <font class="keyword"></font>{
00116   m_file = file;
00117 
00118   <font class="comment">// first time we run, initialize MikMod</font>
00119   <font class="keyword">static</font> <font class="keywordtype">bool</font> initialized = <font class="keyword">false</font>;
00120   <font class="keywordflow">if</font> (!initialized) {
00121     <a class="code" href="debug_8hpp.html#a1">ADR_GUARD</a>(<font class="stringliteral">"Initializing MikMod"</font>);
00122 
00123     Mikmod_RegisterLoader(load_it);
00124     Mikmod_RegisterLoader(load_xm);
00125     Mikmod_RegisterLoader(load_s3m);
00126     Mikmod_RegisterLoader(load_mod);
00127     Mikmod_RegisterLoader(load_stm);
00128     
00129     Mikmod_RegisterDriver(drv_acq);
00130 
00131     initialized = <font class="keyword">true</font>;
00132   }
00133 
00134   m_stream.fp      = (FILE*)<font class="keyword">this</font>;
00135   m_stream.dp      = 0;
00136   m_stream.iobase  = 0;
00137   m_stream.seekpos = 0;
00138   m_stream.fread   = MMRead;
00139   m_stream.fwrite  = MMWrite;
00140   m_stream.fgetc   = MMGetC;
00141   m_stream.fputc   = MMPutC;
00142   m_stream.fseek   = MMSeek;
00143   m_stream.ftell   = MMTell;
00144   m_stream.feof    = MMEof;
00145 
00146   m_samples_left = 0;
00147   m_next_sample  = m_next_sample;
00148 
00149   m_at_eof = <font class="keyword">false</font>;
00150 
00151   <font class="comment">// create output device</font>
00152   m_driver = Mikmod_Init(
00153     44100, 2400, <font class="keyword">this</font>, MD_STEREO, CPU_AUTODETECT,
00154     DMODE_16BITS | DMODE_INTERP | DMODE_NOCLICK);
00155   <font class="keywordflow">if</font> (!m_driver) {
00156     m_file = 0;
00157     <font class="keywordflow">return</font> <font class="keyword">false</font>;
00158   }
00159 
00160   <a class="code" href="debug_8hpp.html#a2">ADR_LOG</a>(<font class="stringliteral">"Mikmod_Init succeeded"</font>);
00161 
00162   <font class="comment">// load the song</font>
00163   m_module = Unimod_LoadFP(
00164     m_driver,
00165     &amp;m_stream,
00166     &amp;m_stream,
00167     MM_STATIC);
00168   <font class="keywordflow">if</font> (!m_module) {
00169     Mikmod_Exit(m_driver);
00170     m_driver = 0;
00171     m_file = 0;
00172     <font class="keywordflow">return</font> <font class="keyword">false</font>;
00173   }
00174 
00175   <a class="code" href="debug_8hpp.html#a2">ADR_LOG</a>(<font class="stringliteral">"Unimod_LoadFP succeeded"</font>);
00176 
00177   <font class="comment">// load the samples (???)</font>
00178   <font class="keywordflow">if</font> (SL_LoadSamples(m_driver)) {
00179     Unimod_Free(m_module);
00180     m_module = 0;
00181     Mikmod_Exit(m_driver);
00182     m_driver = 0;
00183     m_file = 0;
00184     <font class="keywordflow">return</font> <font class="keyword">false</font>;
00185   }
00186 
00187   <a class="code" href="debug_8hpp.html#a2">ADR_LOG</a>(<font class="stringliteral">"SL_LoadSamples succeeded"</font>);
00188 
00189   <font class="comment">// create a player</font>
00190   m_player = Player_InitSong(m_module, NULL, 0, 64);
00191   <font class="keywordflow">if</font> (!m_player) {
00192     Unimod_Free(m_module);
00193     m_module = 0;
00194     Mikmod_Exit(m_driver);
00195     m_driver = 0;
00196     m_file = 0;
00197     <font class="keywordflow">return</font> <font class="keyword">false</font>;
00198   }
00199 
00200   <a class="code" href="debug_8hpp.html#a2">ADR_LOG</a>(<font class="stringliteral">"Player_InitSong succeeded"</font>);
00201 
00202   <font class="comment">// start playback of the module</font>
00203   <font class="comment">// we won't actually get samples until the read call</font>
00204   Player_Start(m_player);
00205 
00206   <a class="code" href="debug_8hpp.html#a2">ADR_LOG</a>(<font class="stringliteral">"Player_Start succeeded"</font>);
00207 
00208   <font class="keywordflow">return</font> <font class="keyword">true</font>;
00209 }
00210 
00212 
00213 <font class="keywordtype">void</font>
<a name="l00214"></a><a class="code" href="classMODInputStream.html#a3">00214</a> <a class="code" href="classMODInputStream.html#a3">MODInputStream::GetFormat</a>(
00215   <font class="keywordtype">int</font>&amp; channel_count,
00216   <font class="keywordtype">int</font>&amp; sample_rate,
00217   <font class="keywordtype">int</font>&amp; bits_per_sample)<font class="keyword"></font>
00218 <font class="keyword"></font>{
00219   channel_count   = 2;
00220   sample_rate     = 44100;
00221   bits_per_sample = 16;
00222 }
00223 
00225 
00226 <font class="keywordtype">int</font>
<a name="l00227"></a><a class="code" href="classMODInputStream.html#a4">00227</a> <a class="code" href="classMODInputStream.html#a4">MODInputStream::Read</a>(<font class="keywordtype">int</font> sample_count, <font class="keywordtype">void</font>* samples)<font class="keyword"></font>
00228 <font class="keyword"></font>{
00229   <a class="code" href="debug_8hpp.html#a1">ADR_GUARD</a>(<font class="stringliteral">"MOD_Read"</font>);
00230 
00231   adr_u32* out = reinterpret_cast&lt;adr_u32*&gt;(samples);
00232 
00233   <font class="keywordtype">int</font> total_written = 0;
00234   <font class="keywordflow">while</font> (sample_count &gt; 0) {
00235 
00236     <font class="comment">// if there are no samples in the buffer, tell mikmod to give us a few</font>
00237     <font class="keywordflow">if</font> (m_samples_left == 0) {
00238 
00239       <font class="comment">// if the song isn't playing any more, just stop</font>
00240       <font class="keywordflow">if</font> (!Player_Active(m_player)) {
00241         <font class="keywordflow">break</font>;
00242       }
00243 
00244       Mikmod_Update(m_driver);
00245     }
00246 
00247     <font class="comment">// read data out of the buffer</font>
00248     adr_u32 samples_to_read = adr_min&lt;adr_u32&gt;(
00249       sample_count,
00250       m_samples_left);
00251     memcpy(out, m_next_sample, samples_to_read * 4);
00252 
00253     <font class="comment">// update pointers and indices and counts, oh my</font>
00254     out            += samples_to_read;    
00255     m_next_sample  += samples_to_read;
00256     m_samples_left -= samples_to_read;
00257     sample_count   -= samples_to_read;
00258     total_written  += samples_to_read;
00259   }
00260 
00261   <font class="keywordflow">return</font> total_written;
00262 }
00263 
00265 
00266 <font class="keywordtype">bool</font>
<a name="l00267"></a><a class="code" href="classMODInputStream.html#a5">00267</a> <a class="code" href="classMODInputStream.html#a5">MODInputStream::Reset</a>()<font class="keyword"></font>
00268 <font class="keyword"></font>{
00269   <a class="code" href="debug_8hpp.html#a1">ADR_GUARD</a>(<font class="stringliteral">"MOD_Reset"</font>);
00270 
00271   m_samples_left = 0;
00272   m_next_sample  = m_sample_buffer;
00273 
00274   Player_Stop(m_player);
00275   Player_Start(m_player);
00276   <font class="keywordflow">return</font> <font class="keyword">true</font>;
00277 }
00278 
00280 
00281 BOOL
00282 MODInputStream::ACQ_IsThere()<font class="keyword"></font>
00283 <font class="keyword"></font>{
00284   <font class="keywordflow">return</font> 1;
00285 }
00286 
00288 
00289 BOOL
00290 MODInputStream::ACQ_Init(MDRIVER* md, uint latency, <font class="keywordtype">void</font>* optstr)<font class="keyword"></font>
00291 <font class="keyword"></font>{
00292   <a class="code" href="debug_8hpp.html#a1">ADR_GUARD</a>(<font class="stringliteral">"ACQ_Init"</font>);
00293 
00294   md-&gt;device.vc = VC_Init();
00295   <font class="keywordflow">if</font> (!md-&gt;device.vc) {
00296     <font class="keywordflow">return</font> 1;
00297   }
00298 
00299   md-&gt;device.local = optstr;
00300   <font class="keywordflow">return</font> 0;
00301 }
00302 
00304 
00305 <font class="keywordtype">void</font>
00306 MODInputStream::ACQ_Exit(MDRIVER* md)<font class="keyword"></font>
00307 <font class="keyword"></font>{
00308   <a class="code" href="debug_8hpp.html#a1">ADR_GUARD</a>(<font class="stringliteral">"ACQ_Exit"</font>);
00309 
00310   VC_Exit(md-&gt;device.vc);
00311 }
00312 
00314 
00315 <font class="keywordtype">void</font>
00316 MODInputStream::ACQ_Update(MDRIVER* md)<font class="keyword"></font>
00317 <font class="keyword"></font>{
00318   <a class="code" href="debug_8hpp.html#a1">ADR_GUARD</a>(<font class="stringliteral">"ACQ_Update"</font>);
00319 
00320   <a class="code" href="classMODInputStream.html">MODInputStream</a>* stream = reinterpret_cast&lt;MODInputStream*&gt;(md-&gt;device.local);
00321 
00322   <font class="comment">// we should only write into the buffer if it's empty</font>
00323   <font class="keywordflow">if</font> (stream-&gt;m_samples_left != 0) {
00324     <font class="keywordflow">return</font>;
00325   }
00326 
00327   VC_WriteBytes(
00328     md,
00329     (<font class="keywordtype">signed</font> <font class="keywordtype">char</font>*)stream-&gt;m_sample_buffer,
00330     SAMPLE_BUFFER_SIZE * <font class="keyword">sizeof</font>(adr_u32));
00331   stream-&gt;m_samples_left = SAMPLE_BUFFER_SIZE;
00332   stream-&gt;m_next_sample = stream-&gt;m_sample_buffer;
00333 }
00334 
00336 
00337 BOOL
00338 MODInputStream::ACQ_SetSoftVoices(MDRIVER* md, uint voices)<font class="keyword"></font>
00339 <font class="keyword"></font>{
00340   <font class="keywordflow">return</font> VC_SetSoftVoices(md-&gt;device.vc, voices);
00341 }
00342 
00344 
00345 BOOL
00346 MODInputStream::ACQ_SetMode(MDRIVER* md, uint mixspeed, uint mode,
00347                  uint channels, uint cpumode)<font class="keyword"></font>
00348 <font class="keyword"></font>{
00349   <font class="keywordflow">return</font> VC_SetMode(md-&gt;device.vc, mixspeed, mode, channels, cpumode);
00350 }
00351 
00353 
00354 <font class="keywordtype">void</font>
00355 MODInputStream::ACQ_GetMode(MDRIVER* md, uint* mixspeed, uint* mode,
00356                  uint* channels, uint* cpumode)<font class="keyword"></font>
00357 <font class="keyword"></font>{
00358   VC_GetMode(md-&gt;device.vc, mixspeed, mode, channels, cpumode);
00359 }
00360 
00362 
00363 <font class="keywordtype">int</font> CRT_CALL
00364 MODInputStream::MMRead(<font class="keywordtype">void</font>* buffer, size_t size, size_t count, FILE* stream)<font class="keyword"></font>
00365 <font class="keyword"></font>{
00366   <a class="code" href="classMODInputStream.html">MODInputStream</a>* istream = reinterpret_cast&lt;MODInputStream*&gt;(stream);
00367   <font class="keywordtype">int</font> result = istream-&gt;m_file-&gt;<a class="code" href="classMODInputStream.html#a4">Read</a>(buffer, size * count) / size;
00368   <font class="keywordflow">if</font> (result == 0) {
00369     istream-&gt;m_at_eof = <font class="keyword">true</font>;
00370   }
00371   <font class="keywordflow">return</font> result;
00372 }
00373 
00375 
00376 <font class="keywordtype">int</font> CRT_CALL
00377 MODInputStream::MMWrite(<font class="keyword">const</font> <font class="keywordtype">void</font>* buffer, size_t size, size_t count, FILE* stream)<font class="keyword"></font>
00378 <font class="keyword"></font>{
00379   <font class="comment">// we can't write</font>
00380   <font class="keywordflow">return</font> -1;
00381 }
00382 
00384 
00385 <font class="keywordtype">int</font> CRT_CALL
00386 MODInputStream::MMGetC(FILE* stream)<font class="keyword"></font>
00387 <font class="keyword"></font>{
00388   <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font> c;
00389   <font class="keywordflow">if</font> (MMRead(&amp;c, 1, 1, stream) == 1) {
00390     <font class="keywordflow">return</font> c;
00391   } <font class="keywordflow">else</font> {
00392    <font class="keywordflow">return</font> EOF;
00393   }
00394 }
00395 
00397 
00398 <font class="keywordtype">int</font> CRT_CALL
00399 MODInputStream::MMPutC(<font class="keywordtype">int</font> c, FILE* stream)<font class="keyword"></font>
00400 <font class="keyword"></font>{
00401   <font class="keywordtype">char</font> ch = (<font class="keywordtype">char</font>)c;
00402   <font class="keywordflow">return</font> MMWrite(&amp;ch, 1, 1, stream);
00403 }
00404 
00406 
00407 <font class="keywordtype">int</font> CRT_CALL
00408 MODInputStream::MMSeek(FILE* stream, <font class="keywordtype">long</font> offset, <font class="keywordtype">int</font> origin)<font class="keyword"></font>
00409 <font class="keyword"></font>{
00410   <a class="code" href="classMODInputStream.html">MODInputStream</a>* istream = reinterpret_cast&lt;MODInputStream*&gt;(stream);
00411   <a class="code" href="classIFile.html">IFile</a>* file = istream-&gt;m_file;
00412 
00413   ADR_SEEK_TYPE seek_type;
00414   <font class="keywordflow">switch</font> (origin) {
00415     <font class="keywordflow">case</font> SEEK_SET: seek_type = ADR_BEGIN;   <font class="keywordflow">break</font>;
00416     <font class="keywordflow">case</font> SEEK_CUR: seek_type = ADR_CURRENT; <font class="keywordflow">break</font>;
00417     <font class="keywordflow">case</font> SEEK_END: seek_type = ADR_END;     <font class="keywordflow">break</font>;
00418     <font class="keywordflow">default</font>: <font class="keywordflow">return</font> -1;
00419   }
00420 
00421   <font class="keywordflow">return</font> file-&gt;<a class="code" href="classIFile.html#a2">Seek</a>(offset, seek_type) ? 0 : -1;
00422 }
00423 
00425 
00426 <font class="keywordtype">int</font> CRT_CALL
00427 MODInputStream::MMTell(FILE* stream)<font class="keyword"></font>
00428 <font class="keyword"></font>{
00429   <a class="code" href="classMODInputStream.html">MODInputStream</a>* istream = reinterpret_cast&lt;MODInputStream*&gt;(stream);
00430   <a class="code" href="classIFile.html">IFile</a>* file = istream-&gt;m_file;
00431   <font class="keywordflow">return</font> file-&gt;<a class="code" href="classIFile.html#a3">Tell</a>();
00432 }
00433 
00435 
00436 <font class="keywordtype">int</font> CRT_CALL
00437 MODInputStream::MMEof(FILE* stream)<font class="keyword"></font>
00438 <font class="keyword"></font>{
00439   <a class="code" href="classMODInputStream.html">MODInputStream</a>* istream = reinterpret_cast&lt;MODInputStream*&gt;(stream);
00440   <font class="keywordflow">return</font> istream-&gt;m_at_eof ? 1 : 0;
00441 }
00442 
</pre></div><hr><address><small>Generated at Mon Jun 10 02:55:12 2002 for audiere by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.8.1 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
