<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>input_ogg.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.8.1 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>input_ogg.cpp</h1><a href="input__ogg_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="preprocessor">#include &lt;string.h&gt;</font>
00002 <font class="preprocessor">#include "<a class="code" href="input__ogg_8hpp.html">input_ogg.hpp</a>"</font>
00003 <font class="preprocessor">#include "<a class="code" href="config_8h.html">config.h</a>"</font>
00004 <font class="preprocessor">#include "<a class="code" href="utility_8hpp.html">utility.hpp</a>"</font>
00005 
00006 
<a name="l00007"></a><a class="code" href="structOGG__INTERNAL.html">00007</a> <font class="keyword">struct </font><a class="code" href="structOGG__INTERNAL.html">OGG_INTERNAL</a>
00008 {
<a name="l00009"></a><a class="code" href="structOGG__INTERNAL.html#m0">00009</a>   OggVorbis_File vf;
<a name="l00010"></a><a class="code" href="structOGG__INTERNAL.html#m1">00010</a>   adr_u32 location;
<a name="l00011"></a><a class="code" href="structOGG__INTERNAL.html#m2">00011</a>   <font class="keywordtype">bool</font> eof;
00012 };
00013 
00014 
<a name="l00015"></a><a class="code" href="input__ogg_8cpp.html#a0">00015</a> <font class="keyword">typedef</font> ogg_int64_t int64_t;
00016 
00017 
00019 
<a name="l00020"></a><a class="code" href="classOGGInputStream.html#a0">00020</a> <a class="code" href="classOGGInputStream.html#a0">OGGInputStream::OGGInputStream</a>()<font class="keyword"></font>
00021 <font class="keyword"></font>{
00022   m_file = 0;
00023 <font class="comment">//  m_eof  = false;</font>
00024 
00025   m_channel_count   = 0;
00026   m_sample_rate     = 0;
00027   m_bits_per_sample = 0;
00028 }
00029 
00031 
<a name="l00032"></a><a class="code" href="classOGGInputStream.html#a1">00032</a> <a class="code" href="classOGGInputStream.html#a1">OGGInputStream::~OGGInputStream</a>()<font class="keyword"></font>
00033 <font class="keyword"></font>{
00034   <font class="comment">// were we initialized successfully?</font>
00035   <font class="keywordflow">if</font> (m_file) {
00036     ov_clear(&amp;m_vorbis_file);
00037 
00038     <font class="keyword">delete</font> m_file;
00039     m_file = 0;
00040   }
00041 }
00042 
00044 
00045 <font class="keywordtype">bool</font>
<a name="l00046"></a><a class="code" href="classOGGInputStream.html#a2">00046</a> <a class="code" href="classOGGInputStream.html#a2">OGGInputStream::Initialize</a>(<a class="code" href="classIFile.html">IFile</a>* file)<font class="keyword"></font>
00047 <font class="keyword"></font>{
00048   m_file = file;
00049 
00050   <font class="comment">// custom ogg vorbis callbacks</font>
00051   ov_callbacks callbacks;
00052   callbacks.read_func  = FileRead;
00053   callbacks.seek_func  = FileSeek;
00054   callbacks.close_func = FileClose;
00055   callbacks.tell_func  = FileTell;
00056 
00057   <font class="comment">// open ogg vorbis stream</font>
00058   <font class="keywordtype">int</font> result = ov_open_callbacks(file, &amp;m_vorbis_file, 0, 0, callbacks);
00059   <font class="keywordflow">if</font> (result) {
00060     m_file = 0;
00061     <font class="keywordflow">return</font> <font class="keyword">false</font>;
00062   }
00063 
00064   <font class="comment">// calculate stream type</font>
00065   vorbis_info* vi = ov_info(&amp;m_vorbis_file, -1);
00066   <font class="keywordflow">if</font> (!vi) {
00067     ov_clear(&amp;m_vorbis_file);
00068     m_file = 0;
00069     <font class="keywordflow">return</font> <font class="keyword">false</font>;
00070   }
00071 
00072   m_channel_count   = vi-&gt;channels;
00073   m_bits_per_sample = 16;
00074   m_sample_rate     = vi-&gt;rate;
00075 
00076   <font class="keywordflow">return</font> <font class="keyword">true</font>;
00077 }
00078 
00080 
00081 <font class="keywordtype">void</font>
<a name="l00082"></a><a class="code" href="classOGGInputStream.html#a3">00082</a> <a class="code" href="classOGGInputStream.html#a3">OGGInputStream::GetFormat</a>(
00083   <font class="keywordtype">int</font>&amp; channel_count,
00084   <font class="keywordtype">int</font>&amp; sample_rate,
00085   <font class="keywordtype">int</font>&amp; bits_per_sample)<font class="keyword"></font>
00086 <font class="keyword"></font>{
00087   channel_count   = m_channel_count;
00088   sample_rate     = m_sample_rate;
00089   bits_per_sample = m_bits_per_sample;
00090 }
00091 
00093 
00094 <font class="keywordtype">int</font>
<a name="l00095"></a><a class="code" href="classOGGInputStream.html#a4">00095</a> <a class="code" href="classOGGInputStream.html#a4">OGGInputStream::Read</a>(<font class="keywordtype">int</font> sample_count, <font class="keywordtype">void</font>* samples)<font class="keyword"></font>
00096 <font class="keyword"></font>{
00097   <font class="keywordtype">int</font> sample_size = m_bits_per_sample * m_channel_count / 8;
00098 
00099   <font class="comment">// if we're at the end of the file, we have no more samples</font>
00100 <font class="comment">//  if (m_eof) {</font>
00101 <font class="comment">//    return 0;</font>
00102 <font class="comment">//  }</font>
00103   
00104   adr_u8* out = (adr_u8*)samples;
00105 
00106   <font class="keywordtype">int</font> samples_left = sample_count;
00107   <font class="keywordtype">int</font> total_read = 0;
00108   <font class="keywordflow">while</font> (samples_left &gt; 0 <font class="comment">/*&amp;&amp; !m_eof*/</font>) {
00109 
00110     <font class="comment">// check to see if the stream format has changed</font>
00111     <font class="comment">// if so, treat it as an EndOfStream</font>
00112     vorbis_info* vi = ov_info(&amp;m_vorbis_file, -1);
00113     <font class="keywordflow">if</font> (vi &amp;&amp; (m_sample_rate != vi-&gt;rate || m_channel_count != vi-&gt;channels)) {
00114 <font class="comment">//      m_eof = true;</font>
00115       <font class="keywordflow">break</font>;
00116     }
00117 
00118     <font class="keywordtype">int</font> bitstream;
00119     <font class="keywordtype">long</font> result = ov_read(
00120       &amp;m_vorbis_file,
00121       (<font class="keywordtype">char</font>*)out,
00122       samples_left * sample_size,
00123       0,  <font class="comment">// little endian</font>
00124       2,  <font class="comment">// 16-bit</font>
00125       1,  <font class="comment">// signed</font>
00126       &amp;bitstream);
00127 
00128     <font class="keywordflow">if</font> (result &lt; 0) {
00129       <font class="comment">// if error, ignore it</font>
00130       <font class="keywordflow">continue</font>;
00131     } <font class="keywordflow">else</font> <font class="keywordflow">if</font> (result == 0) {
00132 <font class="comment">//      m_eof = true;</font>
00133       <font class="keywordflow">break</font>;
00134     }
00135 
00136     adr_u32 samples_read = (adr_u32)(result / sample_size);
00137 
00138     out += samples_read * sample_size;
00139     samples_left -= samples_read;
00140     total_read   += samples_read;
00141   }
00142 
00143   <font class="keywordflow">return</font> total_read;
00144 }
00145 
00147 
00148 <font class="keywordtype">bool</font>
<a name="l00149"></a><a class="code" href="classOGGInputStream.html#a5">00149</a> <a class="code" href="classOGGInputStream.html#a5">OGGInputStream::Reset</a>()<font class="keyword"></font>
00150 <font class="keyword"></font>{
00151   <font class="keywordflow">return</font> (0 == ov_pcm_seek(&amp;m_vorbis_file, 0));
00152 }
00153 
00155 
00156 size_t
00157 OGGInputStream::FileRead(<font class="keywordtype">void</font>* buffer, size_t size, size_t n, <font class="keywordtype">void</font>* opaque)<font class="keyword"></font>
00158 <font class="keyword"></font>{
00159   <a class="code" href="classIFile.html">IFile</a>* file = reinterpret_cast&lt;IFile*&gt;(opaque);
00160   <font class="keywordflow">return</font> file-&gt;<a class="code" href="classIFile.html#a1">Read</a>(buffer, size * n) / size;
00161 }
00162 
00164 
00165 <font class="keywordtype">int</font>
00166 OGGInputStream::FileSeek(<font class="keywordtype">void</font>* opaque, ogg_int64_t offset, <font class="keywordtype">int</font> whence)<font class="keyword"></font>
00167 <font class="keyword"></font>{
00168   <a class="code" href="classIFile.html">IFile</a>* file = reinterpret_cast&lt;IFile*&gt;(opaque);
00169   ADR_SEEK_TYPE type;
00170   <font class="keywordflow">switch</font> (whence) {
00171     <font class="keywordflow">case</font> SEEK_SET: type = ADR_BEGIN;   <font class="keywordflow">break</font>;
00172     <font class="keywordflow">case</font> SEEK_CUR: type = ADR_CURRENT; <font class="keywordflow">break</font>;
00173     <font class="keywordflow">case</font> SEEK_END: type = ADR_END;     <font class="keywordflow">break</font>;
00174     <font class="keywordflow">default</font>: <font class="keywordflow">return</font> -1;
00175   }
00176   <font class="keywordflow">return</font> (file-&gt;<a class="code" href="classIFile.html#a2">Seek</a>((<font class="keywordtype">int</font>)offset, type) ? 0 : -1);
00177 }
00178 
00180 
00181 <font class="keywordtype">int</font>
00182 OGGInputStream::FileClose(<font class="keywordtype">void</font>* <font class="comment">/*opaque*/</font>)<font class="keyword"></font>
00183 <font class="keyword"></font>{
00184   <font class="comment">// we don't have to do anything</font>
00185   <font class="comment">// (read: don't trust ogg vorbis with handling file closes)</font>
00186   <font class="keywordflow">return</font> 0;
00187 }
00188 
00190 
00191 <font class="keywordtype">long</font>
00192 OGGInputStream::FileTell(<font class="keywordtype">void</font>* opaque)<font class="keyword"></font>
00193 <font class="keyword"></font>{
00194   <a class="code" href="classIFile.html">IFile</a>* file = reinterpret_cast&lt;IFile*&gt;(opaque);
00195   <font class="keywordflow">return</font> file-&gt;<a class="code" href="classIFile.html#a3">Tell</a>();
00196 }
00197 
</pre></div><hr><address><small>Generated at Mon Jun 10 02:55:12 2002 for audiere by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.8.1 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
