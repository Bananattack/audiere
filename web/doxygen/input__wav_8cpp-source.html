<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>input_wav.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.8.1 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>input_wav.cpp</h1><a href="input__wav_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="preprocessor">#include "<a class="code" href="input__wav_8hpp.html">input_wav.hpp</a>"</font>
00002 <font class="preprocessor">#include "<a class="code" href="endian_8hpp.html">endian.hpp</a>"</font>
00003 <font class="preprocessor">#include "<a class="code" href="utility_8hpp.html">utility.hpp</a>"</font>
00004 
00005 
00006 <font class="keyword">static</font> <font class="keyword">inline</font> adr_u16 Read16(adr_u8* m)<font class="keyword"> </font>{
00007   <font class="keywordflow">return</font> (adr_u16)(
00008     (m[0] &lt;&lt; 0) +
00009     (m[1] &lt;&lt; 8)
00010   );
00011 }
00012 
00013 <font class="keyword">static</font> <font class="keyword">inline</font> adr_u32 Read32(adr_u8* m)<font class="keyword"> </font>{
00014   <font class="keywordflow">return</font> (adr_u32)(
00015     (m[0] &lt;&lt; 0) +
00016     (m[1] &lt;&lt; 8) +
00017     (m[2] &lt;&lt; 16)  +
00018     (m[3] &lt;&lt; 24)
00019   );
00020 }
00021 
00022 <font class="keyword">static</font> <font class="keyword">inline</font> <font class="keywordtype">bool</font> IsValidSampleSize(adr_u32 size)<font class="keyword"> </font>{
00023   <font class="keywordflow">return</font> (size == 8 || size == 16);
00024 }
00025 
00027 
<a name="l00028"></a><a class="code" href="classWAVInputStream.html#a0">00028</a> <a class="code" href="classWAVInputStream.html#a0">WAVInputStream::WAVInputStream</a>()<font class="keyword"></font>
00029 <font class="keyword"></font>{
00030   m_file = 0;
00031 
00032   m_channel_count   = 0;
00033   m_bits_per_sample = 0;
00034   m_sample_rate     = 0;
00035 
00036   m_data_chunk_location = 0;
00037   m_data_chunk_length   = 0;
00038 
00039   m_samples_left_in_chunk = 0;
00040 }
00041 
00043 
<a name="l00044"></a><a class="code" href="classWAVInputStream.html#a1">00044</a> <a class="code" href="classWAVInputStream.html#a1">WAVInputStream::~WAVInputStream</a>()<font class="keyword"></font>
00045 <font class="keyword"></font>{
00046   <font class="keyword">delete</font> m_file;
00047   m_file = 0;
00048 }
00049 
00051 
00052 <font class="keywordtype">bool</font>
<a name="l00053"></a><a class="code" href="classWAVInputStream.html#a2">00053</a> <a class="code" href="classWAVInputStream.html#a2">WAVInputStream::Initialize</a>(<a class="code" href="classIFile.html">IFile</a>* file)<font class="keyword"></font>
00054 <font class="keyword"></font>{
00055   m_file = file;
00056 
00057   <font class="comment">// read the RIFF header</font>
00058   <font class="keywordtype">char</font>    riff_id[4];
00059   adr_u32 riff_length;
00060   <font class="keywordtype">char</font>    riff_datatype[4];
00061 
00062   adr_u32 size = 0;
00063   size += file-&gt;<a class="code" href="classIFile.html#a1">Read</a>(riff_id, 4);
00064   size += file-&gt;<a class="code" href="classIFile.html#a1">Read</a>(&amp;riff_length, 4);
00065   size += file-&gt;<a class="code" href="classIFile.html#a1">Read</a>(riff_datatype, 4);
00066 
00067   riff_length = <a class="code" href="endian_8hpp.html#a4">LittleToHost32</a>(riff_length);
00068 
00069   <font class="keywordflow">if</font> (size != 12 ||
00070       memcmp(riff_id, <font class="stringliteral">"RIFF"</font>, 4) != 0 ||
00071       riff_length == 0 ||
00072       memcmp(riff_datatype, <font class="stringliteral">"WAVE"</font>, 4) != 0) {
00073 
00074     <font class="comment">// so we don't destroy the file</font>
00075     m_file = 0;
00076     <font class="keywordflow">return</font> <font class="keyword">false</font>;
00077   }
00078 
00079   <font class="keywordflow">if</font> (FindFormatChunk() &amp;&amp; FindDataChunk()) {
00080     <font class="keywordflow">return</font> <font class="keyword">true</font>;
00081   } <font class="keywordflow">else</font> {
00082     m_file = 0;
00083     <font class="keywordflow">return</font> <font class="keyword">false</font>;
00084   }
00085 }
00086 
00088 
00089 <font class="keywordtype">void</font>
<a name="l00090"></a><a class="code" href="classWAVInputStream.html#a3">00090</a> <a class="code" href="classWAVInputStream.html#a3">WAVInputStream::GetFormat</a>(
00091   <font class="keywordtype">int</font>&amp; channel_count,
00092   <font class="keywordtype">int</font>&amp; sample_rate,
00093   <font class="keywordtype">int</font>&amp; bits_per_sample)<font class="keyword"></font>
00094 <font class="keyword"></font>{
00095   channel_count   = m_channel_count;
00096   sample_rate     = m_sample_rate;
00097   bits_per_sample = m_bits_per_sample;
00098 }
00099 
00101 
00102 <font class="keywordtype">int</font>
<a name="l00103"></a><a class="code" href="classWAVInputStream.html#a4">00103</a> <a class="code" href="classWAVInputStream.html#a4">WAVInputStream::Read</a>(<font class="keywordtype">int</font> sample_count, <font class="keywordtype">void</font>* samples)<font class="keyword"></font>
00104 <font class="keyword"></font>{
00105   <font class="keywordflow">if</font> (m_samples_left_in_chunk == 0) {
00106     <font class="keywordflow">return</font> 0;
00107   }
00108 
00109   <font class="keyword">const</font> <font class="keywordtype">int</font> samples_to_read = <a class="code" href="utility_8hpp.html#a2">adr_min</a>(sample_count, m_samples_left_in_chunk);
00110   <font class="keyword">const</font> <font class="keywordtype">int</font> sample_size = m_channel_count * m_bits_per_sample / 8;
00111   <font class="keyword">const</font> <font class="keywordtype">int</font> bytes_to_read = samples_to_read * sample_size;
00112   
00113   <font class="keyword">const</font> <font class="keywordtype">int</font> read = m_file-&gt;<a class="code" href="classIFile.html#a1">Read</a>(samples, bytes_to_read);
00114   <font class="keyword">const</font> <font class="keywordtype">int</font> samples_read = read / sample_size;
00115 
00116   <font class="comment">// assume that if we didn't get a full read, we're done</font>
00117   <font class="keywordflow">if</font> (read != bytes_to_read) {
00118     m_samples_left_in_chunk = 0;
00119     <font class="keywordflow">return</font> samples_read;
00120   }
00121 
00122   m_samples_left_in_chunk -= samples_read;
00123   <font class="keywordflow">return</font> samples_read;
00124 }
00125 
00127 
00128 <font class="keywordtype">bool</font>
<a name="l00129"></a><a class="code" href="classWAVInputStream.html#a5">00129</a> <a class="code" href="classWAVInputStream.html#a5">WAVInputStream::Reset</a>()<font class="keyword"></font>
00130 <font class="keyword"></font>{
00131   <font class="comment">// seek to the beginning of the data chunk</font>
00132   m_samples_left_in_chunk = m_data_chunk_length;
00133   <font class="keywordflow">return</font> m_file-&gt;<a class="code" href="classIFile.html#a2">Seek</a>(m_data_chunk_location, ADR_BEGIN);
00134 }
00135 
00137 
00138 <font class="keywordtype">bool</font>
00139 WAVInputStream::FindFormatChunk()<font class="keyword"></font>
00140 <font class="keyword"></font>{
00141   <font class="comment">// seek to just after the RIFF header</font>
00142   m_file-&gt;<a class="code" href="classIFile.html#a2">Seek</a>(12, ADR_BEGIN);
00143 
00144   <font class="comment">// search for a format chunk</font>
00145   <font class="keywordflow">while</font> (<font class="keyword">true</font>) {
00146     <font class="keywordtype">char</font>    chunk_id[4];
00147     adr_u32 chunk_length;
00148 
00149     <font class="keywordtype">int</font> size = m_file-&gt;<a class="code" href="classIFile.html#a1">Read</a>(chunk_id, 4);
00150     size    += m_file-&gt;<a class="code" href="classIFile.html#a1">Read</a>(&amp;chunk_length, 4);
00151     chunk_length = <a class="code" href="endian_8hpp.html#a4">LittleToHost32</a>(chunk_length);
00152 
00153     <font class="comment">// if we couldn't read enough, we're done</font>
00154     <font class="keywordflow">if</font> (size != 8) {
00155       <font class="keywordflow">return</font> <font class="keyword">false</font>;
00156     }
00157 
00158     <font class="comment">// if we found a format chunk, excellent!</font>
00159     <font class="keywordflow">if</font> (memcmp(chunk_id, <font class="stringliteral">"fmt "</font>, 4) == 0 &amp;&amp; chunk_length &gt;= 16) {
00160 
00161       <font class="comment">// read format chunk</font>
00162       adr_u8 chunk[16];
00163       size = m_file-&gt;<a class="code" href="classIFile.html#a1">Read</a>(chunk, 16);
00164 
00165       <font class="comment">// could we read the entire format chunk?</font>
00166       <font class="keywordflow">if</font> (size &lt; 16) {
00167         <font class="keywordflow">return</font> <font class="keyword">false</font>;
00168       }
00169 
00170       chunk_length -= size;
00171 
00172       <font class="comment">// parse the memory into useful information</font>
00173       adr_u16 format_tag         = Read16(chunk + 0);
00174       adr_u16 channel_count      = Read16(chunk + 2);
00175       adr_u32 samples_per_second = Read32(chunk + 4);
00176       adr_u32 bytes_per_second   = Read32(chunk + 8);
00177       adr_u16 block_align        = Read16(chunk + 12);
00178       adr_u16 bits_per_sample    = Read16(chunk + 14);
00179 
00180       <font class="comment">// format_tag must be 1 (WAVE_FORMAT_PCM)</font>
00181       <font class="comment">// we only support mono and stereo</font>
00182       <font class="keywordflow">if</font> (format_tag != 1 ||
00183           channel_count &gt; 2 ||
00184           !IsValidSampleSize(bits_per_sample)) {
00185         <font class="keywordflow">return</font> <font class="keyword">false</font>;
00186       }
00187 
00188       <font class="comment">// skip the rest of the chunk</font>
00189       <font class="keywordflow">if</font> (!SkipBytes(chunk_length)) {
00190         <font class="comment">// oops, end of stream</font>
00191         <font class="keywordflow">return</font> <font class="keyword">false</font>;
00192       }
00193 
00194       <font class="comment">// set format</font>
00195       m_channel_count   = channel_count;
00196       m_bits_per_sample = bits_per_sample;
00197       m_sample_rate     = samples_per_second;
00198       <font class="keywordflow">return</font> <font class="keyword">true</font>;
00199 
00200     } <font class="keywordflow">else</font> {
00201 
00202       <font class="comment">// skip the rest of the chunk</font>
00203       <font class="keywordflow">if</font> (!SkipBytes(chunk_length)) {
00204         <font class="comment">// oops, end of stream</font>
00205         <font class="keywordflow">return</font> <font class="keyword">false</font>;
00206       }
00207 
00208     }
00209   }
00210 }
00211 
00213 
00214 <font class="keywordtype">bool</font>
00215 WAVInputStream::FindDataChunk()<font class="keyword"></font>
00216 <font class="keyword"></font>{
00217   <font class="comment">// seek to just after the RIFF header</font>
00218   m_file-&gt;<a class="code" href="classIFile.html#a2">Seek</a>(12, ADR_BEGIN);
00219 
00220   <font class="comment">// search for a format chunk</font>
00221   <font class="keywordflow">while</font> (<font class="keyword">true</font>) {
00222     <font class="keywordtype">char</font>    chunk_id[4];
00223     adr_u32 chunk_length;
00224 
00225     <font class="keywordtype">int</font> size = m_file-&gt;<a class="code" href="classIFile.html#a1">Read</a>(chunk_id, 4);
00226     size    += m_file-&gt;<a class="code" href="classIFile.html#a1">Read</a>(&amp;chunk_length, 4);
00227     chunk_length = <a class="code" href="endian_8hpp.html#a4">LittleToHost32</a>(chunk_length);
00228 
00229     <font class="comment">// if we couldn't read enough, we're done</font>
00230     <font class="keywordflow">if</font> (size != 8) {
00231       <font class="keywordflow">return</font> <font class="keyword">false</font>;
00232     }
00233 
00234     <font class="comment">// if we found a data chunk, excellent!</font>
00235     <font class="keywordflow">if</font> (memcmp(chunk_id, <font class="stringliteral">"data"</font>, 4) == 0) {
00236 
00237       <font class="comment">// calculate the sample size so we can truncate the data chunk</font>
00238       <font class="keywordtype">int</font> sample_size = m_channel_count * m_bits_per_sample / 8;
00239 
00240       m_data_chunk_location   = m_file-&gt;<a class="code" href="classIFile.html#a3">Tell</a>();
00241       m_data_chunk_length     = chunk_length / sample_size;
00242       m_samples_left_in_chunk = m_data_chunk_length;
00243       <font class="keywordflow">return</font> <font class="keyword">true</font>;
00244 
00245     } <font class="keywordflow">else</font> {
00246 
00247       <font class="comment">// skip the rest of the chunk</font>
00248       <font class="keywordflow">if</font> (!SkipBytes(chunk_length)) {
00249         <font class="comment">// oops, end of stream</font>
00250         <font class="keywordflow">return</font> <font class="keyword">false</font>;
00251       }
00252 
00253     }
00254   }
00255 }
00256 
00258 
00259 <font class="keywordtype">bool</font>
00260 WAVInputStream::SkipBytes(<font class="keywordtype">int</font> size)<font class="keyword"></font>
00261 <font class="keyword"></font>{
00262   <font class="keywordflow">if</font> (m_file-&gt;<a class="code" href="classIFile.html#a2">Seek</a>(size, ADR_CURRENT)) {
00263     m_samples_left_in_chunk = m_data_chunk_length;
00264     <font class="keywordflow">return</font> <font class="keyword">true</font>;
00265   } <font class="keywordflow">else</font> {
00266     <font class="keywordflow">return</font> <font class="keyword">false</font>;
00267   }
00268 }
00269 
</pre></div><hr><address><small>Generated at Mon Jun 10 02:55:12 2002 for audiere by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.8.1 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
